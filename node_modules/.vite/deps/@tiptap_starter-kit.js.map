{
  "version": 3,
  "sources": ["../../@tiptap/core/src/jsx-runtime.ts", "../../@tiptap/extension-blockquote/src/blockquote.tsx", "../../@tiptap/extension-blockquote/src/index.ts", "../../@tiptap/extension-bold/src/bold.tsx", "../../@tiptap/extension-bold/src/index.ts", "../../@tiptap/extension-code/src/code.ts", "../../@tiptap/extension-code/src/index.ts", "../../@tiptap/extension-code-block/src/code-block.ts", "../../@tiptap/extension-code-block/src/index.ts", "../../@tiptap/extension-document/src/document.ts", "../../@tiptap/extension-document/src/index.ts", "../../@tiptap/extension-hard-break/src/hard-break.ts", "../../@tiptap/extension-hard-break/src/index.ts", "../../@tiptap/extension-heading/src/heading.ts", "../../@tiptap/extension-heading/src/index.ts", "../../@tiptap/extension-horizontal-rule/src/horizontal-rule.ts", "../../@tiptap/extension-horizontal-rule/src/index.ts", "../../@tiptap/extension-italic/src/italic.ts", "../../@tiptap/extension-italic/src/index.ts", "../../linkifyjs/dist/linkify.mjs", "../../@tiptap/extension-link/src/link.ts", "../../@tiptap/extension-link/src/helpers/autolink.ts", "../../@tiptap/extension-link/src/helpers/whitespace.ts", "../../@tiptap/extension-link/src/helpers/clickHandler.ts", "../../@tiptap/extension-link/src/helpers/pasteHandler.ts", "../../@tiptap/extension-link/src/index.ts", "../../@tiptap/extension-list/src/bullet-list/bullet-list.ts", "../../@tiptap/extension-list/src/item/list-item.ts", "../../@tiptap/extension-list/src/keymap/list-keymap.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/index.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/findListItemPos.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/getNextListDepth.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/handleBackspace.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/hasListBefore.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/hasListItemBefore.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/listItemHasSubList.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/handleDelete.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/nextListIsDeeper.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/nextListIsHigher.ts", "../../@tiptap/extension-list/src/keymap/listHelpers/hasListItemAfter.ts", "../../@tiptap/extension-list/src/kit/index.ts", "../../@tiptap/extension-list/src/ordered-list/ordered-list.ts", "../../@tiptap/extension-list/src/ordered-list/utils.ts", "../../@tiptap/extension-list/src/task-item/task-item.ts", "../../@tiptap/extension-list/src/task-list/task-list.ts", "../../@tiptap/extension-paragraph/src/paragraph.ts", "../../@tiptap/extension-paragraph/src/index.ts", "../../@tiptap/extension-strike/src/strike.ts", "../../@tiptap/extension-strike/src/index.ts", "../../@tiptap/extension-text/src/text.ts", "../../@tiptap/extension-text/src/index.ts", "../../@tiptap/extension-underline/src/underline.ts", "../../@tiptap/extension-underline/src/index.ts", "../../@tiptap/starter-kit/src/starter-kit.ts", "../../@tiptap/starter-kit/src/index.ts"],
  "sourcesContent": ["export type Attributes = Record<string, any>\n\nexport type DOMOutputSpecElement = 0 | Attributes | DOMOutputSpecArray\n/**\n * Better describes the output of a `renderHTML` function in prosemirror\n * @see https://prosemirror.net/docs/ref/#model.DOMOutputSpec\n */\nexport type DOMOutputSpecArray =\n  | [string]\n  | [string, Attributes]\n  | [string, 0]\n  | [string, Attributes, 0]\n  | [string, Attributes, DOMOutputSpecArray | 0]\n  | [string, DOMOutputSpecArray]\n\n// JSX types for Tiptap's JSX runtime\n// These types only apply when using @jsxImportSource @tiptap/core\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace JSX {\n  export type Element = DOMOutputSpecArray\n  export interface IntrinsicElements {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any\n  }\n  export interface ElementChildrenAttribute {\n    children: unknown\n  }\n}\n\nexport type JSXRenderer = (\n  tag: 'slot' | string | ((props?: Attributes) => DOMOutputSpecArray | DOMOutputSpecElement),\n  props?: Attributes,\n  ...children: JSXRenderer[]\n) => DOMOutputSpecArray | DOMOutputSpecElement\n\nexport function Fragment(props: { children: JSXRenderer[] }) {\n  return props.children\n}\n\nexport const h: JSXRenderer = (tag, attributes) => {\n  // Treat the slot tag as the Prosemirror hole to render content into\n  if (tag === 'slot') {\n    return 0\n  }\n\n  // If the tag is a function, call it with the props\n  if (tag instanceof Function) {\n    return tag(attributes)\n  }\n\n  const { children, ...rest } = attributes ?? {}\n\n  if (tag === 'svg') {\n    throw new Error('SVG elements are not supported in the JSX syntax, use the array syntax instead')\n  }\n\n  // Otherwise, return the tag, attributes, and children\n  return [tag, rest, children]\n}\n\n// See\n// https://esbuild.github.io/api/#jsx-import-source\n// https://www.typescriptlang.org/tsconfig/#jsxImportSource\n\nexport { h as createElement, h as jsx, h as jsxDEV, h as jsxs }\n", "/** @jsxImportSource @tiptap/core */\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  /**\n   * HTML attributes to add to the blockquote element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nexport const inputRegex = /^\\s*>\\s$/\n\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nexport const Blockquote = Node.create<BlockquoteOptions>({\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [{ tag: 'blockquote' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <blockquote {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </blockquote>\n    )\n  },\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('blockquote', undefined, helpers.parseChildren(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    // Use a single '>' prefix regardless of nesting level\n    // Nested blockquotes will add their own '>' prefix recursively\n    const prefix = '>'\n    const result: string[] = []\n\n    node.content.forEach(child => {\n      // Render each child node as an array so it gets processed properly\n      const childContent = h.renderChildren([child])\n      const lines = childContent.split('\\n')\n\n      const linesWithPrefix = lines.map(line => {\n        // Don't add prefix to empty lines\n        if (line.trim() === '') {\n          return prefix\n        }\n\n        // Nested blockquotes will already have their own prefixes\n        // We just need to add our own prefix at the start\n        return `${prefix} ${line}`\n      })\n\n      result.push(linesWithPrefix.join('\\n'))\n    })\n\n    // Add separator lines between children\n    return result.join(`\\n${prefix}\\n`)\n  },\n\n  addCommands() {\n    return {\n      setBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.wrapIn(this.name)\n        },\n      toggleBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.toggleWrap(this.name)\n        },\n      unsetBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.lift(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Blockquote } from './blockquote.jsx'\n\nexport * from './blockquote.jsx'\n\nexport default Blockquote\n", "/** @jsxImportSource @tiptap/core */\nimport { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface BoldOptions {\n  /**\n   * HTML attributes to add to the bold element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => ReturnType\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => ReturnType\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches bold text via `**` as input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/\n\n/**\n * Matches bold text via `**` while pasting.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g\n\n/**\n * Matches bold text via `__` as input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/\n\n/**\n * Matches bold text via `__` while pasting.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g\n\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight=400',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <strong {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </strong>\n    )\n  },\n\n  markdownTokenName: 'strong',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'strong' token to bold mark\n    return helpers.applyMark('bold', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`\n  },\n\n  addCommands() {\n    return {\n      setBold:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleBold:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetBold:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n      'Mod-B': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Bold } from './bold.jsx'\n\nexport * from './bold.jsx'\n\nexport default Bold\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface CodeOptions {\n  /**\n   * The HTML attributes applied to the code element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    code: {\n      /**\n       * Set a code mark\n       */\n      setCode: () => ReturnType\n      /**\n       * Toggle inline code\n       */\n      toggleCode: () => ReturnType\n      /**\n       * Unset a code mark\n       */\n      unsetCode: () => ReturnType\n    }\n  }\n}\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick as the final character.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nexport const inputRegex = /(^|[^`])`([^`]+)`(?!`)$/\n\n/**\n * Matches inline code while pasting.\n */\nexport const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g\n\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nexport const Code = Mark.create<CodeOptions>({\n  name: 'code',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  excludes: '_',\n\n  code: true,\n\n  exitable: true,\n\n  parseHTML() {\n    return [{ tag: 'code' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'codespan',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'codespan' token to code mark\n    // For codespan tokens, we use the raw text content, not tokens\n    return helpers.applyMark('code', [{ type: 'text', text: token.text || '' }])\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return `\\`${h.renderChildren(node.content)}\\``\n  },\n\n  addCommands() {\n    return {\n      setCode:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleCode:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetCode:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-e': () => this.editor.commands.toggleCode(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Code } from './code.js'\n\nexport * from './code.js'\n\nexport default Code\n", "import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, Selection, TextSelection } from '@tiptap/pm/state'\n\nconst DEFAULT_TAB_SIZE = 4\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * @default 'language-'\n   */\n  languageClassPrefix: string | null | undefined\n  /**\n   * Define whether the node should be exited on triple enter.\n   * @default true\n   */\n  exitOnTripleEnter: boolean | null | undefined\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * @default true\n   */\n  exitOnArrowDown: boolean | null | undefined\n  /**\n   * The default language.\n   * @default null\n   * @example 'js'\n   */\n  defaultLanguage: string | null | undefined\n  /**\n   * Enable tab key for indentation in code blocks.\n   * @default false\n   */\n  enableTabIndentation: boolean | null | undefined\n  /**\n   * The number of spaces to use for tab indentation.\n   * @default 4\n   */\n  tabSize: number | null | undefined\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.setCodeBlock({ language: 'javascript' })\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType\n      /**\n       * Toggle a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.toggleCodeBlock({ language: 'javascript' })\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a code block with backticks.\n */\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\n\n/**\n * Matches a code block with tildes.\n */\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n\n          if (!languageClassPrefix) {\n            return null\n          }\n\n          const classNames = [...(element.firstElementChild?.classList || [])]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  markdownTokenName: 'code',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.raw?.startsWith('```') === false && token.codeBlockStyle !== 'indented') {\n      return []\n    }\n\n    return helpers.createNode(\n      'codeBlock',\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : [],\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    let output = ''\n    const language = node.attrs?.language || ''\n\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\\n\\n\\`\\`\\``\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), '```']\n      output = lines.join('\\n')\n    }\n\n    return output\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.setNode(this.name, attributes)\n        },\n      toggleCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        const indent = ' '.repeat(tabSize)\n\n        if (empty) {\n          return editor.commands.insertContent(indent)\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const indentedText = lines.map(line => indent + line).join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(indentedText))\n          return true\n        })\n      },\n\n      // handle shift+tab reverse indentation\n      'Shift-Tab': ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            const { pos } = $from\n            const codeBlockStart = $from.start()\n            const codeBlockEnd = $from.end()\n\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, '\\n', '\\n')\n            const lines = allText.split('\\n')\n\n            let currentLineIndex = 0\n            let charCount = 0\n            const relativeCursorPos = pos - codeBlockStart\n\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i\n                break\n              }\n              charCount += lines[i].length + 1\n            }\n\n            const currentLine = lines[currentLineIndex]\n            const leadingSpaces = currentLine.match(/^ */)?.[0] || ''\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n\n            if (spacesToRemove === 0) {\n              return true\n            }\n\n            let lineStartPos = codeBlockStart\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1\n            }\n\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove)\n\n            const cursorPosInLine = pos - lineStartPos\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos))\n            }\n\n            return true\n          })\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const reverseIndentText = lines\n            .map(line => {\n              const leadingSpaces = line.match(/^ */)?.[0] || ''\n              const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n              return line.slice(spacesToRemove)\n            })\n            .join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText))\n          return true\n        })\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)))\n            return true\n          })\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // don’t create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode ? JSON.parse(vscode) : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr, schema } = view.state\n\n            // prepare a text node\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'))\n\n            // create a code block with the text node\n            // replace selection with the code block\n            tr.replaceSelectionWith(this.type.create({ language }, textNode))\n\n            if (tr.selection.$from.parent.type !== this.type) {\n              // put cursor inside the newly created code block\n              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n            }\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n", "import { CodeBlock } from './code-block.js'\n\nexport * from './code-block.js'\n\nexport default CodeBlock\n", "import { Node } from '@tiptap/core'\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n\\n')\n  },\n})\n", "import { Document } from './document.js'\n\nexport * from './document.js'\n\nexport default Document\n", "import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  /**\n   * Controls if marks should be kept after being split by a hard break.\n   * @default true\n   * @example false\n   */\n  keepMarks: boolean\n\n  /**\n   * HTML attributes to add to the hard break element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       * @example editor.commands.setHardBreak()\n       */\n      setHardBreak: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  markdownTokenName: 'br',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  parseHTML() {\n    return [{ tag: 'br' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  renderMarkdown: () => `  \\n`,\n\n  parseMarkdown: () => {\n    return {\n      type: 'hardBreak',\n    }\n  },\n\n  addCommands() {\n    return {\n      setHardBreak:\n        () =>\n        ({ commands, chain, state, editor }) => {\n          return commands.first([\n            () => commands.exitCode(),\n            () =>\n              commands.command(() => {\n                const { selection, storedMarks } = state\n\n                if (selection.$from.parent.type.spec.isolating) {\n                  return false\n                }\n\n                const { keepMarks } = this.options\n                const { splittableMarks } = editor.extensionManager\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n                return chain()\n                  .insertContent({ type: this.name })\n                  .command(({ tr, dispatch }) => {\n                    if (dispatch && marks && keepMarks) {\n                      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n                      tr.ensureMarks(filteredMarks)\n                    }\n\n                    return true\n                  })\n                  .run()\n              }),\n          ])\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n", "import { HardBreak } from './hard-break.js'\n\nexport * from './hard-break.js'\n\nexport default HardBreak\n", "import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\n\n/**\n * The heading level options.\n */\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  /**\n   * The available heading levels.\n   * @default [1, 2, 3, 4, 5, 6]\n   * @example [1, 2, 3]\n   */\n  levels: Level[]\n\n  /**\n   * The HTML attributes for a heading node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    heading: {\n      /**\n       * Set a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.setHeading({ level: 1 })\n       */\n      setHeading: (attributes: { level: Level }) => ReturnType\n      /**\n       * Toggle a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.toggleHeading({ level: 1 })\n       */\n      toggleHeading: (attributes: { level: Level }) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels.map((level: Level) => ({\n      tag: `h${level}`,\n      attrs: { level },\n    }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel ? node.attrs.level : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'heading' token to heading node\n    // marked provides 'depth' property (1-6) for heading level\n    return helpers.createNode('heading', { level: token.depth || 1 }, helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    const level = node.attrs?.level ? parseInt(node.attrs.level as string, 10) : 1\n    const headingChars = '#'.repeat(level)\n\n    if (!node.content) {\n      return ''\n    }\n\n    // Use current context for proper joining/spacing\n    return `${headingChars} ${h.renderChildren(node.content)}`\n  },\n\n  addCommands() {\n    return {\n      setHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.setNode(this.name, attributes)\n        },\n      toggleHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n        },\n      }),\n      {},\n    )\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level,\n        },\n      })\n    })\n  },\n})\n", "import { Heading } from './heading.js'\n\nexport * from './heading.js'\n\nexport default Heading\n", "import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * The default type to insert after the horizontal rule.\n   * @default \"paragraph\"\n   * @example \"heading\"\n   */\n  nextNodeType: string\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: 'paragraph',\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  markdownTokenName: 'hr',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('horizontalRule')\n  },\n\n  renderMarkdown: () => {\n    return '---'\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ state: chainState, tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const nodeType =\n                      chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType\n                    const node = nodeType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { HorizontalRule } from './horizontal-rule.js'\n\nexport * from './horizontal-rule.js'\n\nexport default HorizontalRule\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface ItalicOptions {\n  /**\n   * HTML attributes to add to the italic element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    italic: {\n      /**\n       * Set an italic mark\n       * @example editor.commands.setItalic()\n       */\n      setItalic: () => ReturnType\n      /**\n       * Toggle an italic mark\n       * @example editor.commands.toggleItalic()\n       */\n      toggleItalic: () => ReturnType\n      /**\n       * Unset an italic mark\n       * @example editor.commands.unsetItalic()\n       */\n      unsetItalic: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an italic to a *italic* on input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/\n\n/**\n * Matches an italic to a *italic* on paste.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g\n\n/**\n * Matches an italic to a _italic_ on input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/\n\n/**\n * Matches an italic to a _italic_ on paste.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g\n\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=normal',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleItalic:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetItalic:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  markdownTokenName: 'em',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'em' token to italic mark\n    return helpers.applyMark('italic', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n      'Mod-I': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Italic } from './italic.js'\n\nexport * from './italic.js'\n\nexport default Italic\n", "// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\r\n// See update-tlds.js for encoding/decoding format\r\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\r\nconst encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\r\n// Internationalized domain names containing non-ASCII\r\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\r\n\r\n/**\r\n * Finite State Machine generation utilities\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ [group: string]: T[] }} Collections\r\n */\r\n\r\n/**\r\n * @typedef {{ [group: string]: true }} Flags\r\n */\r\n\r\n// Keys in scanner Collections instances\r\nconst numeric = 'numeric';\r\nconst ascii = 'ascii';\r\nconst alpha = 'alpha';\r\nconst asciinumeric = 'asciinumeric';\r\nconst alphanumeric = 'alphanumeric';\r\nconst domain = 'domain';\r\nconst emoji = 'emoji';\r\nconst scheme = 'scheme';\r\nconst slashscheme = 'slashscheme';\r\nconst whitespace = 'whitespace';\r\n\r\n/**\r\n * @template T\r\n * @param {string} name\r\n * @param {Collections<T>} groups to register in\r\n * @returns {T[]} Current list of tokens in the given collection\r\n */\r\nfunction registerGroup(name, groups) {\r\n  if (!(name in groups)) {\r\n    groups[name] = [];\r\n  }\r\n  return groups[name];\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {T} t token to add\r\n * @param {Collections<T>} groups\r\n * @param {Flags} flags\r\n */\r\nfunction addToGroups(t, flags, groups) {\r\n  if (flags[numeric]) {\r\n    flags[asciinumeric] = true;\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[ascii]) {\r\n    flags[asciinumeric] = true;\r\n    flags[alpha] = true;\r\n  }\r\n  if (flags[asciinumeric]) {\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[alpha]) {\r\n    flags[alphanumeric] = true;\r\n  }\r\n  if (flags[alphanumeric]) {\r\n    flags[domain] = true;\r\n  }\r\n  if (flags[emoji]) {\r\n    flags[domain] = true;\r\n  }\r\n  for (const k in flags) {\r\n    const group = registerGroup(k, groups);\r\n    if (group.indexOf(t) < 0) {\r\n      group.push(t);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {T} t token to check\r\n * @param {Collections<T>} groups\r\n * @returns {Flags} group flags that contain this token\r\n */\r\nfunction flagsForToken(t, groups) {\r\n  const result = {};\r\n  for (const c in groups) {\r\n    if (groups[c].indexOf(t) >= 0) {\r\n      result[c] = true;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @template T\r\n * @typedef {null | T } Transition\r\n */\r\n\r\n/**\r\n * Define a basic state machine state. j is the list of character transitions,\r\n * jr is the list of regex-match transitions, jd is the default state to\r\n * transition to t is the accepting token type, if any. If this is the terminal\r\n * state, then it does not emit a token.\r\n *\r\n * The template type T represents the type of the token this state accepts. This\r\n * should be a string (such as of the token exports in `text.js`) or a\r\n * MultiToken subclass (from `multi.js`)\r\n *\r\n * @template T\r\n * @param {T} [token] Token that this state emits\r\n */\r\nfunction State(token = null) {\r\n  // this.n = null; // DEBUG: State name\r\n  /** @type {{ [input: string]: State<T> }} j */\r\n  this.j = {}; // IMPLEMENTATION 1\r\n  // this.j = []; // IMPLEMENTATION 2\r\n  /** @type {[RegExp, State<T>][]} jr */\r\n  this.jr = [];\r\n  /** @type {?State<T>} jd */\r\n  this.jd = null;\r\n  /** @type {?T} t */\r\n  this.t = token;\r\n}\r\n\r\n/**\r\n * Scanner token groups\r\n * @type Collections<string>\r\n */\r\nState.groups = {};\r\nState.prototype = {\r\n  accepts() {\r\n    return !!this.t;\r\n  },\r\n  /**\r\n   * Follow an existing transition from the given input to the next state.\r\n   * Does not mutate.\r\n   * @param {string} input character or token type to transition on\r\n   * @returns {?State<T>} the next state, if any\r\n   */\r\n  go(input) {\r\n    const state = this;\r\n    const nextState = state.j[input];\r\n    if (nextState) {\r\n      return nextState;\r\n    }\r\n    for (let i = 0; i < state.jr.length; i++) {\r\n      const regex = state.jr[i][0];\r\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\r\n      if (nextState && regex.test(input)) {\r\n        return nextState;\r\n      }\r\n    }\r\n    // Nowhere left to jump! Return default, if any\r\n    return state.jd;\r\n  },\r\n  /**\r\n   * Whether the state has a transition for the given input. Set the second\r\n   * argument to true to only look for an exact match (and not a default or\r\n   * regular-expression-based transition)\r\n   * @param {string} input\r\n   * @param {boolean} exactOnly\r\n   */\r\n  has(input, exactOnly = false) {\r\n    return exactOnly ? input in this.j : !!this.go(input);\r\n  },\r\n  /**\r\n   * Short for \"transition all\"; create a transition from the array of items\r\n   * in the given list to the same final resulting state.\r\n   * @param {string | string[]} inputs Group of inputs to transition on\r\n   * @param {Transition<T> | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   */\r\n  ta(inputs, next, flags, groups) {\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      this.tt(inputs[i], next, flags, groups);\r\n    }\r\n  },\r\n  /**\r\n   * Short for \"take regexp transition\"; defines a transition for this state\r\n   * when it encounters a token which matches the given regular expression\r\n   * @param {RegExp} regexp Regular expression transition (populate first)\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  tr(regexp, next, flags, groups) {\r\n    groups = groups || State.groups;\r\n    let nextState;\r\n    if (next && next.j) {\r\n      nextState = next;\r\n    } else {\r\n      // Token with maybe token groups\r\n      nextState = new State(next);\r\n      if (flags && groups) {\r\n        addToGroups(next, flags, groups);\r\n      }\r\n    }\r\n    this.jr.push([regexp, nextState]);\r\n    return nextState;\r\n  },\r\n  /**\r\n   * Short for \"take transitions\", will take as many sequential transitions as\r\n   * the length of the given input and returns the\r\n   * resulting final state.\r\n   * @param {string | string[]} input\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of token groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  ts(input, next, flags, groups) {\r\n    let state = this;\r\n    const len = input.length;\r\n    if (!len) {\r\n      return state;\r\n    }\r\n    for (let i = 0; i < len - 1; i++) {\r\n      state = state.tt(input[i]);\r\n    }\r\n    return state.tt(input[len - 1], next, flags, groups);\r\n  },\r\n  /**\r\n   * Short for \"take transition\", this is a method for building/working with\r\n   * state machines.\r\n   *\r\n   * If a state already exists for the given input, returns it.\r\n   *\r\n   * If a token is specified, that state will emit that token when reached by\r\n   * the linkify engine.\r\n   *\r\n   * If no state exists, it will be initialized with some default transitions\r\n   * that resemble existing default transitions.\r\n   *\r\n   * If a state is given for the second argument, that state will be\r\n   * transitioned to on the given input regardless of what that input\r\n   * previously did.\r\n   *\r\n   * Specify a token group flags to define groups that this token belongs to.\r\n   * The token will be added to corresponding entires in the given groups\r\n   * object.\r\n   *\r\n   * @param {string} input character, token type to transition on\r\n   * @param {T | State<T>} [next] Transition options\r\n   * @param {Flags} [flags] Collections flags to add token to\r\n   * @param {Collections<T>} [groups] Master list of groups\r\n   * @returns {State<T>} taken after the given input\r\n   */\r\n  tt(input, next, flags, groups) {\r\n    groups = groups || State.groups;\r\n    const state = this;\r\n\r\n    // Check if existing state given, just a basic transition\r\n    if (next && next.j) {\r\n      state.j[input] = next;\r\n      return next;\r\n    }\r\n    const t = next;\r\n\r\n    // Take the transition with the usual default mechanisms and use that as\r\n    // a template for creating the next state\r\n    let nextState,\r\n      templateState = state.go(input);\r\n    if (templateState) {\r\n      nextState = new State();\r\n      Object.assign(nextState.j, templateState.j);\r\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\r\n      nextState.jd = templateState.jd;\r\n      nextState.t = templateState.t;\r\n    } else {\r\n      nextState = new State();\r\n    }\r\n    if (t) {\r\n      // Ensure newly token is in the same groups as the old token\r\n      if (groups) {\r\n        if (nextState.t && typeof nextState.t === 'string') {\r\n          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);\r\n          addToGroups(t, allFlags, groups);\r\n        } else if (flags) {\r\n          addToGroups(t, flags, groups);\r\n        }\r\n      }\r\n      nextState.t = t; // overwrite anything that was previously there\r\n    }\r\n    state.j[input] = nextState;\r\n    return nextState;\r\n  }\r\n};\r\n\r\n// Helper functions to improve minification (not exported outside linkifyjs module)\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {RegExp} regexp\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string | string[]} input\r\n * @param {T | State<T>} [next]\r\n * @param {Flags} [flags]\r\n * @param {Collections<T>} [groups]\r\n */\r\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\r\n\r\n/**\r\n * @template T\r\n * @param {State<T>} state\r\n * @param {string} input\r\n * @param {T | State<T>} [next]\r\n * @param {Collections<T>} [groups]\r\n * @param {Flags} [flags]\r\n */\r\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\r\n\r\n/******************************************************************************\r\nText Tokens\r\nIdentifiers for token outputs from the regexp scanner\r\n******************************************************************************/\r\n\r\n// A valid web domain token\r\nconst WORD = 'WORD'; // only contains a-z\r\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\r\nconst ASCIINUMERICAL = 'ASCIINUMERICAL'; // contains a-z, 0-9\r\nconst ALPHANUMERICAL = 'ALPHANUMERICAL'; // contains numbers and letters other than a-z, used for IDN\r\n\r\n// Special case of word\r\nconst LOCALHOST = 'LOCALHOST';\r\n\r\n// Valid top-level domain, special case of WORD (see tlds.js)\r\nconst TLD = 'TLD';\r\n\r\n// Valid IDN TLD, special case of UWORD (see tlds.js)\r\nconst UTLD = 'UTLD';\r\n\r\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\r\n// `file`, and user-defined custom protocols. Limited to schemes that contain\r\n// only letters\r\nconst SCHEME = 'SCHEME';\r\n\r\n// Similar to SCHEME, except makes distinction for schemes that must always be\r\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\r\n// `ftp`, `ftps`\r\nconst SLASH_SCHEME = 'SLASH_SCHEME';\r\n\r\n// Any sequence of digits 0-9\r\nconst NUM = 'NUM';\r\n\r\n// Any number of consecutive whitespace characters that are not newline\r\nconst WS = 'WS';\r\n\r\n// New line (unix style)\r\nconst NL = 'NL'; // \\n\r\n\r\n// Opening/closing bracket classes\r\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\r\n// Also rename angle brackes to LESSTHAN and GREATER THAN\r\nconst OPENBRACE = 'OPENBRACE'; // {\r\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\r\nconst OPENBRACKET = 'OPENBRACKET'; // [\r\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\r\nconst OPENPAREN = 'OPENPAREN'; // (\r\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\r\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\r\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\r\nconst FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // （\r\nconst FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // ）\r\nconst LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 「\r\nconst RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 」\r\nconst LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 『\r\nconst RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 』\r\nconst FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // ＜\r\nconst FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // ＞\r\n\r\n// Various symbols\r\nconst AMPERSAND = 'AMPERSAND'; // &\r\nconst APOSTROPHE = 'APOSTROPHE'; // '\r\nconst ASTERISK = 'ASTERISK'; // *\r\nconst AT = 'AT'; // @\r\nconst BACKSLASH = 'BACKSLASH'; // \\\r\nconst BACKTICK = 'BACKTICK'; // `\r\nconst CARET = 'CARET'; // ^\r\nconst COLON = 'COLON'; // :\r\nconst COMMA = 'COMMA'; // ,\r\nconst DOLLAR = 'DOLLAR'; // $\r\nconst DOT = 'DOT'; // .\r\nconst EQUALS = 'EQUALS'; // =\r\nconst EXCLAMATION = 'EXCLAMATION'; // !\r\nconst HYPHEN = 'HYPHEN'; // -\r\nconst PERCENT = 'PERCENT'; // %\r\nconst PIPE = 'PIPE'; // |\r\nconst PLUS = 'PLUS'; // +\r\nconst POUND = 'POUND'; // #\r\nconst QUERY = 'QUERY'; // ?\r\nconst QUOTE = 'QUOTE'; // \"\r\nconst FULLWIDTHMIDDLEDOT = 'FULLWIDTHMIDDLEDOT'; // ・\r\n\r\nconst SEMI = 'SEMI'; // ;\r\nconst SLASH = 'SLASH'; // /\r\nconst TILDE = 'TILDE'; // ~\r\nconst UNDERSCORE = 'UNDERSCORE'; // _\r\n\r\n// Emoji symbol\r\nconst EMOJI$1 = 'EMOJI';\r\n\r\n// Default token - anything that is not one of the above\r\nconst SYM = 'SYM';\r\n\r\nvar tk = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tALPHANUMERICAL: ALPHANUMERICAL,\r\n\tAMPERSAND: AMPERSAND,\r\n\tAPOSTROPHE: APOSTROPHE,\r\n\tASCIINUMERICAL: ASCIINUMERICAL,\r\n\tASTERISK: ASTERISK,\r\n\tAT: AT,\r\n\tBACKSLASH: BACKSLASH,\r\n\tBACKTICK: BACKTICK,\r\n\tCARET: CARET,\r\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\r\n\tCLOSEBRACE: CLOSEBRACE,\r\n\tCLOSEBRACKET: CLOSEBRACKET,\r\n\tCLOSEPAREN: CLOSEPAREN,\r\n\tCOLON: COLON,\r\n\tCOMMA: COMMA,\r\n\tDOLLAR: DOLLAR,\r\n\tDOT: DOT,\r\n\tEMOJI: EMOJI$1,\r\n\tEQUALS: EQUALS,\r\n\tEXCLAMATION: EXCLAMATION,\r\n\tFULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\r\n\tFULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\r\n\tFULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\r\n\tFULLWIDTHMIDDLEDOT: FULLWIDTHMIDDLEDOT,\r\n\tFULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\r\n\tHYPHEN: HYPHEN,\r\n\tLEFTCORNERBRACKET: LEFTCORNERBRACKET,\r\n\tLEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\r\n\tLOCALHOST: LOCALHOST,\r\n\tNL: NL,\r\n\tNUM: NUM,\r\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\r\n\tOPENBRACE: OPENBRACE,\r\n\tOPENBRACKET: OPENBRACKET,\r\n\tOPENPAREN: OPENPAREN,\r\n\tPERCENT: PERCENT,\r\n\tPIPE: PIPE,\r\n\tPLUS: PLUS,\r\n\tPOUND: POUND,\r\n\tQUERY: QUERY,\r\n\tQUOTE: QUOTE,\r\n\tRIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\r\n\tRIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\r\n\tSCHEME: SCHEME,\r\n\tSEMI: SEMI,\r\n\tSLASH: SLASH,\r\n\tSLASH_SCHEME: SLASH_SCHEME,\r\n\tSYM: SYM,\r\n\tTILDE: TILDE,\r\n\tTLD: TLD,\r\n\tUNDERSCORE: UNDERSCORE,\r\n\tUTLD: UTLD,\r\n\tUWORD: UWORD,\r\n\tWORD: WORD,\r\n\tWS: WS\r\n});\r\n\r\n// Note that these two Unicode ones expand into a really big one with Babel\r\nconst ASCII_LETTER = /[a-z]/;\r\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\r\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\r\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\r\nconst DIGIT = /\\d/;\r\nconst SPACE = /\\s/;\r\n\r\nvar regexp = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tASCII_LETTER: ASCII_LETTER,\r\n\tDIGIT: DIGIT,\r\n\tEMOJI: EMOJI,\r\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\r\n\tLETTER: LETTER,\r\n\tSPACE: SPACE\r\n});\r\n\r\n/**\r\n\tThe scanner provides an interface that takes a string of text as input, and\r\n\toutputs an array of tokens instances that can be used for easy URL parsing.\r\n*/\r\n\r\nconst CR = '\\r'; // carriage-return character\r\nconst LF = '\\n'; // line-feed character\r\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\r\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\r\nconst OBJECT_REPLACEMENT = '\\ufffc'; // whitespace placeholder that sometimes appears in rich text editors\r\n\r\nlet tlds = null,\r\n  utlds = null; // don't change so only have to be computed once\r\n\r\n/**\r\n * Scanner output token:\r\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\r\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\r\n * - `s` is the start index of the token in the original string\r\n * - `e` is the end index of the token in the original string\r\n * @typedef {{t: string, v: string, s: number, e: number}} Token\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ [collection: string]: T[] }} Collections\r\n */\r\n\r\n/**\r\n * Initialize the scanner character-based state machine for the given start\r\n * state\r\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\r\n * item is a length-2 tuple with the first element set to the string scheme, and\r\n * the second element set to `true` if the `://` after the scheme is optional\r\n */\r\nfunction init$2(customSchemes = []) {\r\n  // Frequently used states (name argument removed during minification)\r\n  /** @type Collections<string> */\r\n  const groups = {}; // of tokens\r\n  State.groups = groups;\r\n  /** @type State<string> */\r\n  const Start = new State();\r\n  if (tlds == null) {\r\n    tlds = decodeTlds(encodedTlds);\r\n  }\r\n  if (utlds == null) {\r\n    utlds = decodeTlds(encodedUtlds);\r\n  }\r\n\r\n  // States for special URL symbols that accept immediately after start\r\n  tt(Start, \"'\", APOSTROPHE);\r\n  tt(Start, '{', OPENBRACE);\r\n  tt(Start, '}', CLOSEBRACE);\r\n  tt(Start, '[', OPENBRACKET);\r\n  tt(Start, ']', CLOSEBRACKET);\r\n  tt(Start, '(', OPENPAREN);\r\n  tt(Start, ')', CLOSEPAREN);\r\n  tt(Start, '<', OPENANGLEBRACKET);\r\n  tt(Start, '>', CLOSEANGLEBRACKET);\r\n  tt(Start, '（', FULLWIDTHLEFTPAREN);\r\n  tt(Start, '）', FULLWIDTHRIGHTPAREN);\r\n  tt(Start, '「', LEFTCORNERBRACKET);\r\n  tt(Start, '」', RIGHTCORNERBRACKET);\r\n  tt(Start, '『', LEFTWHITECORNERBRACKET);\r\n  tt(Start, '』', RIGHTWHITECORNERBRACKET);\r\n  tt(Start, '＜', FULLWIDTHLESSTHAN);\r\n  tt(Start, '＞', FULLWIDTHGREATERTHAN);\r\n  tt(Start, '&', AMPERSAND);\r\n  tt(Start, '*', ASTERISK);\r\n  tt(Start, '@', AT);\r\n  tt(Start, '`', BACKTICK);\r\n  tt(Start, '^', CARET);\r\n  tt(Start, ':', COLON);\r\n  tt(Start, ',', COMMA);\r\n  tt(Start, '$', DOLLAR);\r\n  tt(Start, '.', DOT);\r\n  tt(Start, '=', EQUALS);\r\n  tt(Start, '!', EXCLAMATION);\r\n  tt(Start, '-', HYPHEN);\r\n  tt(Start, '%', PERCENT);\r\n  tt(Start, '|', PIPE);\r\n  tt(Start, '+', PLUS);\r\n  tt(Start, '#', POUND);\r\n  tt(Start, '?', QUERY);\r\n  tt(Start, '\"', QUOTE);\r\n  tt(Start, '/', SLASH);\r\n  tt(Start, ';', SEMI);\r\n  tt(Start, '~', TILDE);\r\n  tt(Start, '_', UNDERSCORE);\r\n  tt(Start, '\\\\', BACKSLASH);\r\n  tt(Start, '・', FULLWIDTHMIDDLEDOT);\r\n  const Num = tr(Start, DIGIT, NUM, {\r\n    [numeric]: true\r\n  });\r\n  tr(Num, DIGIT, Num);\r\n  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {\r\n    [asciinumeric]: true\r\n  });\r\n  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {\r\n    [alphanumeric]: true\r\n  });\r\n\r\n  // State which emits a word token\r\n  const Word = tr(Start, ASCII_LETTER, WORD, {\r\n    [ascii]: true\r\n  });\r\n  tr(Word, DIGIT, Asciinumeric);\r\n  tr(Word, ASCII_LETTER, Word);\r\n  tr(Asciinumeric, DIGIT, Asciinumeric);\r\n  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);\r\n\r\n  // Same as previous, but specific to non-fsm.ascii alphabet words\r\n  const UWord = tr(Start, LETTER, UWORD, {\r\n    [alpha]: true\r\n  });\r\n  tr(UWord, ASCII_LETTER); // Non-accepting\r\n  tr(UWord, DIGIT, Alphanumeric);\r\n  tr(UWord, LETTER, UWord);\r\n  tr(Alphanumeric, DIGIT, Alphanumeric);\r\n  tr(Alphanumeric, ASCII_LETTER); // Non-accepting\r\n  tr(Alphanumeric, LETTER, Alphanumeric); // Non-accepting\r\n\r\n  // Whitespace jumps\r\n  // Tokens of only non-newline whitespace are arbitrarily long\r\n  // If any whitespace except newline, more whitespace!\r\n  const Nl = tt(Start, LF, NL, {\r\n    [whitespace]: true\r\n  });\r\n  const Cr = tt(Start, CR, WS, {\r\n    [whitespace]: true\r\n  });\r\n  const Ws = tr(Start, SPACE, WS, {\r\n    [whitespace]: true\r\n  });\r\n  tt(Start, OBJECT_REPLACEMENT, Ws);\r\n  tt(Cr, LF, Nl); // \\r\\n\r\n  tt(Cr, OBJECT_REPLACEMENT, Ws);\r\n  tr(Cr, SPACE, Ws);\r\n  tt(Ws, CR); // non-accepting state to avoid mixing whitespaces\r\n  tt(Ws, LF); // non-accepting state to avoid mixing whitespaces\r\n  tr(Ws, SPACE, Ws);\r\n  tt(Ws, OBJECT_REPLACEMENT, Ws);\r\n\r\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\r\n  // zero-width joiner is present\r\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\r\n    [emoji]: true\r\n  });\r\n  tt(Emoji, '#'); // no transition, emoji regex seems to match #\r\n  tr(Emoji, EMOJI, Emoji);\r\n  tt(Emoji, EMOJI_VARIATION, Emoji);\r\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\r\n\r\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\r\n  tt(EmojiJoiner, '#');\r\n  tr(EmojiJoiner, EMOJI, Emoji);\r\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\r\n\r\n  // Generates states for top-level domains\r\n  // Note that this is most accurate when tlds are in alphabetical order\r\n  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];\r\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];\r\n  for (let i = 0; i < tlds.length; i++) {\r\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\r\n  }\r\n  for (let i = 0; i < utlds.length; i++) {\r\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\r\n  }\r\n  addToGroups(TLD, {\r\n    tld: true,\r\n    ascii: true\r\n  }, groups);\r\n  addToGroups(UTLD, {\r\n    utld: true,\r\n    alpha: true\r\n  }, groups);\r\n\r\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\r\n  // get added that are also protocols, set the token to be the same as the\r\n  // protocol to ensure parsing works as expected.\r\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\r\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\r\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\r\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\r\n  addToGroups(SCHEME, {\r\n    scheme: true,\r\n    ascii: true\r\n  }, groups);\r\n  addToGroups(SLASH_SCHEME, {\r\n    slashscheme: true,\r\n    ascii: true\r\n  }, groups);\r\n\r\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\r\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\r\n  for (let i = 0; i < customSchemes.length; i++) {\r\n    const sch = customSchemes[i][0];\r\n    const optionalSlashSlash = customSchemes[i][1];\r\n    const flags = optionalSlashSlash ? {\r\n      [scheme]: true\r\n    } : {\r\n      [slashscheme]: true\r\n    };\r\n    if (sch.indexOf('-') >= 0) {\r\n      flags[domain] = true;\r\n    } else if (!ASCII_LETTER.test(sch)) {\r\n      flags[numeric] = true; // numbers only\r\n    } else if (DIGIT.test(sch)) {\r\n      flags[asciinumeric] = true;\r\n    } else {\r\n      flags[ascii] = true;\r\n    }\r\n    ts(Start, sch, sch, flags);\r\n  }\r\n\r\n  // Localhost token\r\n  ts(Start, 'localhost', LOCALHOST, {\r\n    ascii: true\r\n  });\r\n\r\n  // Set default transition for start state (some symbol)\r\n  Start.jd = new State(SYM);\r\n  return {\r\n    start: Start,\r\n    tokens: Object.assign({\r\n      groups\r\n    }, tk)\r\n  };\r\n}\r\n\r\n/**\r\n\tGiven a string, returns an array of TOKEN instances representing the\r\n\tcomposition of that string.\r\n\r\n\t@method run\r\n\t@param {State<string>} start scanner starting state\r\n\t@param {string} str input string to scan\r\n\t@return {Token[]} list of tokens, each with a type and value\r\n*/\r\nfunction run$1(start, str) {\r\n  // State machine is not case sensitive, so input is tokenized in lowercased\r\n  // form (still returns regular case). Uses selective `toLowerCase` because\r\n  // lowercasing the entire string causes the length and character position to\r\n  // vary in some non-English strings with V8-based runtimes.\r\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\r\n  const charCount = iterable.length; // <= len if there are emojis, etc\r\n  const tokens = []; // return value\r\n\r\n  // cursor through the string itself, accounting for characters that have\r\n  // width with length 2 such as emojis\r\n  let cursor = 0;\r\n\r\n  // Cursor through the array-representation of the string\r\n  let charCursor = 0;\r\n\r\n  // Tokenize the string\r\n  while (charCursor < charCount) {\r\n    let state = start;\r\n    let nextState = null;\r\n    let tokenLength = 0;\r\n    let latestAccepting = null;\r\n    let sinceAccepts = -1;\r\n    let charsSinceAccepts = -1;\r\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\r\n      state = nextState;\r\n\r\n      // Keep track of the latest accepting state\r\n      if (state.accepts()) {\r\n        sinceAccepts = 0;\r\n        charsSinceAccepts = 0;\r\n        latestAccepting = state;\r\n      } else if (sinceAccepts >= 0) {\r\n        sinceAccepts += iterable[charCursor].length;\r\n        charsSinceAccepts++;\r\n      }\r\n      tokenLength += iterable[charCursor].length;\r\n      cursor += iterable[charCursor].length;\r\n      charCursor++;\r\n    }\r\n\r\n    // Roll back to the latest accepting state\r\n    cursor -= sinceAccepts;\r\n    charCursor -= charsSinceAccepts;\r\n    tokenLength -= sinceAccepts;\r\n\r\n    // No more jumps, just make a new token from the last accepting one\r\n    tokens.push({\r\n      t: latestAccepting.t,\r\n      // token type/name\r\n      v: str.slice(cursor - tokenLength, cursor),\r\n      // string value\r\n      s: cursor - tokenLength,\r\n      // start index\r\n      e: cursor // end index (excluding)\r\n    });\r\n  }\r\n  return tokens;\r\n}\r\n\r\n/**\r\n * Convert a String to an Array of characters, taking into account that some\r\n * characters like emojis take up two string indexes.\r\n *\r\n * Adapted from core-js (MIT license)\r\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\r\n *\r\n * @function stringToArray\r\n * @param {string} str\r\n * @returns {string[]}\r\n */\r\nfunction stringToArray(str) {\r\n  const result = [];\r\n  const len = str.length;\r\n  let index = 0;\r\n  while (index < len) {\r\n    let first = str.charCodeAt(index);\r\n    let second;\r\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\r\n    : str.slice(index, index + 2); // two-index characters\r\n    result.push(char);\r\n    index += char.length;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Fast version of ts function for when transition defaults are well known\r\n * @param {State<string>} state\r\n * @param {string} input\r\n * @param {string} t\r\n * @param {string} defaultt\r\n * @param {[RegExp, State<string>][]} jr\r\n * @returns {State<string>}\r\n */\r\nfunction fastts(state, input, t, defaultt, jr) {\r\n  let next;\r\n  const len = input.length;\r\n  for (let i = 0; i < len - 1; i++) {\r\n    const char = input[i];\r\n    if (state.j[char]) {\r\n      next = state.j[char];\r\n    } else {\r\n      next = new State(defaultt);\r\n      next.jr = jr.slice();\r\n      state.j[char] = next;\r\n    }\r\n    state = next;\r\n  }\r\n  next = new State(t);\r\n  next.jr = jr.slice();\r\n  state.j[input[len - 1]] = next;\r\n  return next;\r\n}\r\n\r\n/**\r\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\r\n * into a list of strings.\r\n * @param {str} encoded encoded TLDs string\r\n * @returns {str[]} original TLDs list\r\n */\r\nfunction decodeTlds(encoded) {\r\n  const words = [];\r\n  const stack = [];\r\n  let i = 0;\r\n  let digits = '0123456789';\r\n  while (i < encoded.length) {\r\n    let popDigitCount = 0;\r\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\r\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\r\n    }\r\n    if (popDigitCount > 0) {\r\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\r\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\r\n        stack.pop();\r\n      }\r\n      i += popDigitCount;\r\n    } else {\r\n      stack.push(encoded[i]); // drop down a level into the trie\r\n      i++;\r\n    }\r\n  }\r\n  return words;\r\n}\r\n\r\n/**\r\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\r\n * and each value is an event handler function.\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\r\n * @typedef {?{ [event: string]: Function }} EventListeners\r\n */\r\n\r\n/**\r\n * All formatted properties required to render a link, including `tagName`,\r\n * `attributes`, `content` and `eventListeners`.\r\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\r\n * eventListeners: EventListeners }} IntermediateRepresentation\r\n */\r\n\r\n/**\r\n * Specify either an object described by the template type `O` or a function.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `O`\r\n * @template O\r\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\r\n */\r\n\r\n/**\r\n * Specify either a function described by template type `F` or an object.\r\n *\r\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\r\n * value should be a function with template type `F` that is called when the\r\n * corresponding link type is encountered.\r\n * @template F\r\n * @typedef {F | { [type: string]: F}} OptFn\r\n */\r\n\r\n/**\r\n * Specify either a value with template type `V`, a function that returns `V` or\r\n * an object where each value resolves to `V`.\r\n *\r\n * The function takes a string value (usually the link's href attribute), the\r\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\r\n * of the link. It should return an object of the template type `V`\r\n *\r\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\r\n * Each value should either have type `V` or a function that returns V. This\r\n * function similarly takes a string value and a token.\r\n *\r\n * Example valid types for `Opt<string>`:\r\n *\r\n * ```js\r\n * 'hello'\r\n * (value, type, token) => 'world'\r\n * { url: 'hello', email: (value, token) => 'world'}\r\n * ```\r\n * @template V\r\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\r\n */\r\n\r\n/**\r\n * See available options: https://linkify.js.org/docs/options.html\r\n * @typedef {{\r\n * \tdefaultProtocol?: string,\r\n *  events?: OptObj<EventListeners>,\r\n * \tformat?: Opt<string>,\r\n * \tformatHref?: Opt<string>,\r\n * \tnl2br?: boolean,\r\n * \ttagName?: Opt<any>,\r\n * \ttarget?: Opt<string>,\r\n * \trel?: Opt<string>,\r\n * \tvalidate?: Opt<boolean>,\r\n * \ttruncate?: Opt<number>,\r\n * \tclassName?: Opt<string>,\r\n * \tattributes?: OptObj<({ [attr: string]: any })>,\r\n *  ignoreTags?: string[],\r\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\r\n * }} Opts\r\n */\r\n\r\n/**\r\n * @type Required<Opts>\r\n */\r\nconst defaults = {\r\n  defaultProtocol: 'http',\r\n  events: null,\r\n  format: noop,\r\n  formatHref: noop,\r\n  nl2br: false,\r\n  tagName: 'a',\r\n  target: null,\r\n  rel: null,\r\n  validate: true,\r\n  truncate: Infinity,\r\n  className: null,\r\n  attributes: null,\r\n  ignoreTags: [],\r\n  render: null\r\n};\r\n\r\n/**\r\n * Utility class for linkify interfaces to apply specified\r\n * {@link Opts formatting and rendering options}.\r\n *\r\n * @param {Opts | Options} [opts] Option value overrides.\r\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\r\n *   internal use) default render function that determines how to generate an\r\n *   HTML element based on a link token's derived tagName, attributes and HTML.\r\n *   Similar to render option\r\n */\r\nfunction Options(opts, defaultRender = null) {\r\n  let o = Object.assign({}, defaults);\r\n  if (opts) {\r\n    o = Object.assign(o, opts instanceof Options ? opts.o : opts);\r\n  }\r\n\r\n  // Ensure all ignored tags are uppercase\r\n  const ignoredTags = o.ignoreTags;\r\n  const uppercaseIgnoredTags = [];\r\n  for (let i = 0; i < ignoredTags.length; i++) {\r\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\r\n  }\r\n  /** @protected */\r\n  this.o = o;\r\n  if (defaultRender) {\r\n    this.defaultRender = defaultRender;\r\n  }\r\n  this.ignoreTags = uppercaseIgnoredTags;\r\n}\r\nOptions.prototype = {\r\n  o: defaults,\r\n  /**\r\n   * @type string[]\r\n   */\r\n  ignoreTags: [],\r\n  /**\r\n   * @param {IntermediateRepresentation} ir\r\n   * @returns {any}\r\n   */\r\n  defaultRender(ir) {\r\n    return ir;\r\n  },\r\n  /**\r\n   * Returns true or false based on whether a token should be displayed as a\r\n   * link based on the user options.\r\n   * @param {MultiToken} token\r\n   * @returns {boolean}\r\n   */\r\n  check(token) {\r\n    return this.get('validate', token.toString(), token);\r\n  },\r\n  // Private methods\r\n\r\n  /**\r\n   * Resolve an option's value based on the value of the option and the given\r\n   * params. If operator and token are specified and the target option is\r\n   * callable, automatically calls the function with the given argument.\r\n   * @template {keyof Opts} K\r\n   * @param {K} key Name of option to use\r\n   * @param {string} [operator] will be passed to the target option if it's a\r\n   * function. If not specified, RAW function value gets returned\r\n   * @param {MultiToken} [token] The token from linkify.tokenize\r\n   * @returns {Opts[K] | any}\r\n   */\r\n  get(key, operator, token) {\r\n    const isCallable = operator != null;\r\n    let option = this.o[key];\r\n    if (!option) {\r\n      return option;\r\n    }\r\n    if (typeof option === 'object') {\r\n      option = token.t in option ? option[token.t] : defaults[key];\r\n      if (typeof option === 'function' && isCallable) {\r\n        option = option(operator, token);\r\n      }\r\n    } else if (typeof option === 'function' && isCallable) {\r\n      option = option(operator, token.t, token);\r\n    }\r\n    return option;\r\n  },\r\n  /**\r\n   * @template {keyof Opts} L\r\n   * @param {L} key Name of options object to use\r\n   * @param {string} [operator]\r\n   * @param {MultiToken} [token]\r\n   * @returns {Opts[L] | any}\r\n   */\r\n  getObj(key, operator, token) {\r\n    let obj = this.o[key];\r\n    if (typeof obj === 'function' && operator != null) {\r\n      obj = obj(operator, token.t, token);\r\n    }\r\n    return obj;\r\n  },\r\n  /**\r\n   * Convert the given token to a rendered element that may be added to the\r\n   * calling-interface's DOM\r\n   * @param {MultiToken} token Token to render to an HTML element\r\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\r\n   *   Component, etc.\r\n   */\r\n  render(token) {\r\n    const ir = token.render(this); // intermediate representation\r\n    const renderFn = this.get('render', null, token) || this.defaultRender;\r\n    return renderFn(ir, token.t, token);\r\n  }\r\n};\r\nfunction noop(val) {\r\n  return val;\r\n}\r\n\r\nvar options = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tOptions: Options,\r\n\tdefaults: defaults\r\n});\r\n\r\n/******************************************************************************\r\n\tMulti-Tokens\r\n\tTokens composed of arrays of TextTokens\r\n******************************************************************************/\r\n\r\n/**\r\n * @param {string} value\r\n * @param {Token[]} tokens\r\n */\r\nfunction MultiToken(value, tokens) {\r\n  this.t = 'token';\r\n  this.v = value;\r\n  this.tk = tokens;\r\n}\r\n\r\n/**\r\n * Abstract class used for manufacturing tokens of text tokens. That is rather\r\n * than the value for a token being a small string of text, it's value an array\r\n * of text tokens.\r\n *\r\n * Used for grouping together URLs, emails, hashtags, and other potential\r\n * creations.\r\n * @class MultiToken\r\n * @property {string} t\r\n * @property {string} v\r\n * @property {Token[]} tk\r\n * @abstract\r\n */\r\nMultiToken.prototype = {\r\n  isLink: false,\r\n  /**\r\n   * Return the string this token represents.\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return this.v;\r\n  },\r\n  /**\r\n   * What should the value for this token be in the `href` HTML attribute?\r\n   * Returns the `.toString` value by default.\r\n   * @param {string} [scheme]\r\n   * @return {string}\r\n   */\r\n  toHref(scheme) {\r\n    return this.toString();\r\n  },\r\n  /**\r\n   * @param {Options} options Formatting options\r\n   * @returns {string}\r\n   */\r\n  toFormattedString(options) {\r\n    const val = this.toString();\r\n    const truncate = options.get('truncate', val, this);\r\n    const formatted = options.get('format', val, this);\r\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\r\n  },\r\n  /**\r\n   *\r\n   * @param {Options} options\r\n   * @returns {string}\r\n   */\r\n  toFormattedHref(options) {\r\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\r\n  },\r\n  /**\r\n   * The start index of this token in the original input string\r\n   * @returns {number}\r\n   */\r\n  startIndex() {\r\n    return this.tk[0].s;\r\n  },\r\n  /**\r\n   * The end index of this token in the original input string (up to this\r\n   * index but not including it)\r\n   * @returns {number}\r\n   */\r\n  endIndex() {\r\n    return this.tk[this.tk.length - 1].e;\r\n  },\r\n  /**\r\n  \tReturns an object  of relevant values for this token, which includes keys\r\n  \t* type - Kind of token ('url', 'email', etc.)\r\n  \t* value - Original text\r\n  \t* href - The value that should be added to the anchor tag's href\r\n  \t\tattribute\r\n  \t\t@method toObject\r\n  \t@param {string} [protocol] `'http'` by default\r\n  */\r\n  toObject(protocol = defaults.defaultProtocol) {\r\n    return {\r\n      type: this.t,\r\n      value: this.toString(),\r\n      isLink: this.isLink,\r\n      href: this.toHref(protocol),\r\n      start: this.startIndex(),\r\n      end: this.endIndex()\r\n    };\r\n  },\r\n  /**\r\n   *\r\n   * @param {Options} options Formatting option\r\n   */\r\n  toFormattedObject(options) {\r\n    return {\r\n      type: this.t,\r\n      value: this.toFormattedString(options),\r\n      isLink: this.isLink,\r\n      href: this.toFormattedHref(options),\r\n      start: this.startIndex(),\r\n      end: this.endIndex()\r\n    };\r\n  },\r\n  /**\r\n   * Whether this token should be rendered as a link according to the given options\r\n   * @param {Options} options\r\n   * @returns {boolean}\r\n   */\r\n  validate(options) {\r\n    return options.get('validate', this.toString(), this);\r\n  },\r\n  /**\r\n   * Return an object that represents how this link should be rendered.\r\n   * @param {Options} options Formattinng options\r\n   */\r\n  render(options) {\r\n    const token = this;\r\n    const href = this.toHref(options.get('defaultProtocol'));\r\n    const formattedHref = options.get('formatHref', href, this);\r\n    const tagName = options.get('tagName', href, token);\r\n    const content = this.toFormattedString(options);\r\n    const attributes = {};\r\n    const className = options.get('className', href, token);\r\n    const target = options.get('target', href, token);\r\n    const rel = options.get('rel', href, token);\r\n    const attrs = options.getObj('attributes', href, token);\r\n    const eventListeners = options.getObj('events', href, token);\r\n    attributes.href = formattedHref;\r\n    if (className) {\r\n      attributes.class = className;\r\n    }\r\n    if (target) {\r\n      attributes.target = target;\r\n    }\r\n    if (rel) {\r\n      attributes.rel = rel;\r\n    }\r\n    if (attrs) {\r\n      Object.assign(attributes, attrs);\r\n    }\r\n    return {\r\n      tagName,\r\n      attributes,\r\n      content,\r\n      eventListeners\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Create a new token that can be emitted by the parser state machine\r\n * @param {string} type readable type of the token\r\n * @param {object} props properties to assign or override, including isLink = true or false\r\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\r\n */\r\nfunction createTokenClass(type, props) {\r\n  class Token extends MultiToken {\r\n    constructor(value, tokens) {\r\n      super(value, tokens);\r\n      this.t = type;\r\n    }\r\n  }\r\n  for (const p in props) {\r\n    Token.prototype[p] = props[p];\r\n  }\r\n  Token.t = type;\r\n  return Token;\r\n}\r\n\r\n/**\r\n\tRepresents a list of tokens making up a valid email address\r\n*/\r\nconst Email = createTokenClass('email', {\r\n  isLink: true,\r\n  toHref() {\r\n    return 'mailto:' + this.toString();\r\n  }\r\n});\r\n\r\n/**\r\n\tRepresents some plain text\r\n*/\r\nconst Text = createTokenClass('text');\r\n\r\n/**\r\n\tMulti-linebreak token - represents a line break\r\n\t@class Nl\r\n*/\r\nconst Nl = createTokenClass('nl');\r\n\r\n/**\r\n\tRepresents a list of text tokens making up a valid URL\r\n\t@class Url\r\n*/\r\nconst Url = createTokenClass('url', {\r\n  isLink: true,\r\n  /**\r\n  \tLowercases relevant parts of the domain and adds the protocol if\r\n  \trequired. Note that this will not escape unsafe HTML characters in the\r\n  \tURL.\r\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\r\n  \t@return {string} the full href\r\n  */\r\n  toHref(scheme = defaults.defaultProtocol) {\r\n    // Check if already has a prefix scheme\r\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\r\n  },\r\n  /**\r\n   * Check whether this URL token has a protocol\r\n   * @return {boolean}\r\n   */\r\n  hasProtocol() {\r\n    const tokens = this.tk;\r\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\r\n  }\r\n});\r\n\r\nvar multi = /*#__PURE__*/Object.freeze({\r\n\t__proto__: null,\r\n\tBase: MultiToken,\r\n\tEmail: Email,\r\n\tMultiToken: MultiToken,\r\n\tNl: Nl,\r\n\tText: Text,\r\n\tUrl: Url,\r\n\tcreateTokenClass: createTokenClass\r\n});\r\n\r\n/**\r\n\tNot exactly parser, more like the second-stage scanner (although we can\r\n\ttheoretically hotswap the code here with a real parser in the future... but\r\n\tfor a little URL-finding utility abstract syntax trees may be a little\r\n\toverkill).\r\n\r\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\r\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\r\n\treference)\r\n\r\n\t@module linkify\r\n\t@submodule parser\r\n\t@main run\r\n*/\r\n\r\nconst makeState = arg => new State(arg);\r\n\r\n/**\r\n * Generate the parser multi token-based state machine\r\n * @param {{ groups: Collections<string> }} tokens\r\n */\r\nfunction init$1({\r\n  groups\r\n}) {\r\n  // Types of characters the URL can definitely end in\r\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\r\n\r\n  // Types of tokens that can follow a URL and be part of the query string\r\n  // but cannot be the very last characters\r\n  // Characters that cannot appear in the URL at all should be excluded\r\n  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\r\n\r\n  // For addresses without the mailto prefix\r\n  // Tokens allowed in the localpart of the email\r\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\r\n\r\n  // The universal starting state.\r\n  /**\r\n   * @type State<Token>\r\n   */\r\n  const Start = makeState();\r\n  const Localpart = tt(Start, TILDE); // Local part of the email address\r\n  ta(Localpart, localpartAccepting, Localpart);\r\n  ta(Localpart, groups.domain, Localpart);\r\n  const Domain = makeState(),\r\n    Scheme = makeState(),\r\n    SlashScheme = makeState();\r\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\r\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\r\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\r\n\r\n  ta(Domain, localpartAccepting, Localpart);\r\n  ta(Domain, groups.domain, Domain);\r\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\r\n\r\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\r\n\r\n  // Local part of an email address can be e.g. 'http' or 'mailto'\r\n  tt(Scheme, AT, LocalpartAt);\r\n  tt(SlashScheme, AT, LocalpartAt);\r\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\r\n  ta(LocalpartDot, localpartAccepting, Localpart);\r\n  ta(LocalpartDot, groups.domain, Localpart);\r\n  const EmailDomain = makeState();\r\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\r\n  ta(EmailDomain, groups.domain, EmailDomain);\r\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\r\n  ta(EmailDomainDot, groups.domain, EmailDomain);\r\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\r\n  ta(EmailDomainDot, groups.tld, Email$1);\r\n  ta(EmailDomainDot, groups.utld, Email$1);\r\n  tt(LocalpartAt, LOCALHOST, Email$1);\r\n\r\n  // Hyphen can jump back to a domain name\r\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\r\n  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);\r\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\r\n  ta(Email$1, groups.domain, EmailDomain);\r\n  tt(Email$1, DOT, EmailDomainDot);\r\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\r\n\r\n  // Final possible email states\r\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\r\n  /*const EmailColonPort = */\r\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\r\n\r\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\r\n  // (but not TLDs)\r\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\r\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\r\n  tt(DomainHyphen, HYPHEN, DomainHyphen);\r\n  ta(DomainHyphen, groups.domain, Domain);\r\n  ta(DomainDot, localpartAccepting, Localpart);\r\n  ta(DomainDot, groups.domain, Domain);\r\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\r\n  ta(DomainDot, groups.tld, DomainDotTld);\r\n  ta(DomainDot, groups.utld, DomainDotTld);\r\n  ta(DomainDotTld, groups.domain, Domain);\r\n  ta(DomainDotTld, localpartAccepting, Localpart);\r\n  tt(DomainDotTld, DOT, DomainDot);\r\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\r\n  tt(DomainDotTld, AT, LocalpartAt);\r\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\r\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\r\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\r\n\r\n  // Long URL with optional port and maybe query string\r\n  const Url$1 = makeState(Url);\r\n\r\n  // URL with extra symbols at the end, followed by an opening bracket\r\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\r\n\r\n  // Query strings\r\n  ta(Url$1, qsAccepting, Url$1);\r\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\r\n  ta(UrlNonaccept, qsAccepting, Url$1);\r\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\r\n\r\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\r\n  // Here works with or without scheme:// prefix\r\n  tt(DomainDotTld, SLASH, Url$1);\r\n  tt(DomainDotTldColonPort, SLASH, Url$1);\r\n\r\n  // Note that domains that begin with schemes are treated slighly differently\r\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\r\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\r\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\r\n\r\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\r\n\r\n  // Scheme states can transition to domain states\r\n  ta(Scheme, groups.domain, Domain);\r\n  tt(Scheme, DOT, DomainDot);\r\n  tt(Scheme, HYPHEN, DomainHyphen);\r\n  ta(SlashScheme, groups.domain, Domain);\r\n  tt(SlashScheme, DOT, DomainDot);\r\n  tt(SlashScheme, HYPHEN, DomainHyphen);\r\n\r\n  // Force URL with scheme prefix followed by anything sane\r\n  ta(SchemeColon, groups.domain, Url$1);\r\n  tt(SchemeColon, SLASH, Url$1);\r\n  tt(SchemeColon, QUERY, Url$1);\r\n  ta(UriPrefix, groups.domain, Url$1);\r\n  ta(UriPrefix, qsAccepting, Url$1);\r\n  tt(UriPrefix, SLASH, Url$1);\r\n  const bracketPairs = [[OPENBRACE, CLOSEBRACE],\r\n  // {}\r\n  [OPENBRACKET, CLOSEBRACKET],\r\n  // []\r\n  [OPENPAREN, CLOSEPAREN],\r\n  // ()\r\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\r\n  // <>\r\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\r\n  // （）\r\n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\r\n  // 「」\r\n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\r\n  // 『』\r\n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // ＜＞\r\n  ];\r\n  for (let i = 0; i < bracketPairs.length; i++) {\r\n    const [OPEN, CLOSE] = bracketPairs[i];\r\n    const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\r\n\r\n    // Continue not accepting for open brackets\r\n    tt(UrlNonaccept, OPEN, UrlOpen);\r\n\r\n    // Closing bracket component. This character WILL be included in the URL\r\n    tt(UrlOpen, CLOSE, Url$1);\r\n\r\n    // URL that beings with an opening bracket, followed by a symbols.\r\n    // Note that the final state can still be `UrlOpen` (if the URL has a\r\n    // single opening bracket for some reason).\r\n    const UrlOpenQ = makeState(Url);\r\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\r\n    const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\r\n    ta(UrlOpen, qsNonAccepting);\r\n\r\n    // URL that begins with an opening bracket, followed by some symbols\r\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\r\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\r\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\r\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\r\n\r\n    // Close brace/bracket to become regular URL\r\n    tt(UrlOpenQ, CLOSE, Url$1);\r\n    tt(UrlOpenSyms, CLOSE, Url$1);\r\n  }\r\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\r\n  tt(Start, NL, Nl); // single new line\r\n\r\n  return {\r\n    start: Start,\r\n    tokens: tk\r\n  };\r\n}\r\n\r\n/**\r\n * Run the parser state machine on a list of scanned string-based tokens to\r\n * create a list of multi tokens, each of which represents a URL, email address,\r\n * plain text, etc.\r\n *\r\n * @param {State<MultiToken>} start parser start state\r\n * @param {string} input the original input used to generate the given tokens\r\n * @param {Token[]} tokens list of scanned tokens\r\n * @returns {MultiToken[]}\r\n */\r\nfunction run(start, input, tokens) {\r\n  let len = tokens.length;\r\n  let cursor = 0;\r\n  let multis = [];\r\n  let textTokens = [];\r\n  while (cursor < len) {\r\n    let state = start;\r\n    let secondState = null;\r\n    let nextState = null;\r\n    let multiLength = 0;\r\n    let latestAccepting = null;\r\n    let sinceAccepts = -1;\r\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\r\n      // Starting tokens with nowhere to jump to.\r\n      // Consider these to be just plain text\r\n      textTokens.push(tokens[cursor++]);\r\n    }\r\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\r\n      // Get the next state\r\n      secondState = null;\r\n      state = nextState;\r\n\r\n      // Keep track of the latest accepting state\r\n      if (state.accepts()) {\r\n        sinceAccepts = 0;\r\n        latestAccepting = state;\r\n      } else if (sinceAccepts >= 0) {\r\n        sinceAccepts++;\r\n      }\r\n      cursor++;\r\n      multiLength++;\r\n    }\r\n    if (sinceAccepts < 0) {\r\n      // No accepting state was found, part of a regular text token add\r\n      // the first text token to the text tokens array and try again from\r\n      // the next\r\n      cursor -= multiLength;\r\n      if (cursor < len) {\r\n        textTokens.push(tokens[cursor]);\r\n        cursor++;\r\n      }\r\n    } else {\r\n      // Accepting state!\r\n      // First close off the textTokens (if available)\r\n      if (textTokens.length > 0) {\r\n        multis.push(initMultiToken(Text, input, textTokens));\r\n        textTokens = [];\r\n      }\r\n\r\n      // Roll back to the latest accepting state\r\n      cursor -= sinceAccepts;\r\n      multiLength -= sinceAccepts;\r\n\r\n      // Create a new multitoken\r\n      const Multi = latestAccepting.t;\r\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\r\n      multis.push(initMultiToken(Multi, input, subtokens));\r\n    }\r\n  }\r\n\r\n  // Finally close off the textTokens (if available)\r\n  if (textTokens.length > 0) {\r\n    multis.push(initMultiToken(Text, input, textTokens));\r\n  }\r\n  return multis;\r\n}\r\n\r\n/**\r\n * Utility function for instantiating a new multitoken with all the relevant\r\n * fields during parsing.\r\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\r\n * @param {string} input original input string\r\n * @param {Token[]} tokens consecutive tokens scanned from input string\r\n * @returns {MultiToken}\r\n */\r\nfunction initMultiToken(Multi, input, tokens) {\r\n  const startIdx = tokens[0].s;\r\n  const endIdx = tokens[tokens.length - 1].e;\r\n  const value = input.slice(startIdx, endIdx);\r\n  return new Multi(value, tokens);\r\n}\r\n\r\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\r\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\r\n\r\n// Side-effect initialization state\r\nconst INIT = {\r\n  scanner: null,\r\n  parser: null,\r\n  tokenQueue: [],\r\n  pluginQueue: [],\r\n  customSchemes: [],\r\n  initialized: false\r\n};\r\n\r\n/**\r\n * @typedef {{\r\n * \tstart: State<string>,\r\n * \ttokens: { groups: Collections<string> } & typeof tk\r\n * }} ScannerInit\r\n */\r\n\r\n/**\r\n * @typedef {{\r\n * \tstart: State<MultiToken>,\r\n * \ttokens: typeof multi\r\n * }} ParserInit\r\n */\r\n\r\n/**\r\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\r\n */\r\n\r\n/**\r\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\r\n */\r\n\r\n/**\r\n * De-register all plugins and reset the internal state-machine. Used for\r\n * testing; not required in practice.\r\n * @private\r\n */\r\nfunction reset() {\r\n  State.groups = {};\r\n  INIT.scanner = null;\r\n  INIT.parser = null;\r\n  INIT.tokenQueue = [];\r\n  INIT.pluginQueue = [];\r\n  INIT.customSchemes = [];\r\n  INIT.initialized = false;\r\n  return INIT;\r\n}\r\n\r\n/**\r\n * Register a token plugin to allow the scanner to recognize additional token\r\n * types before the parser state machine is constructed from the results.\r\n * @param {string} name of plugin to register\r\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\r\n * and available scanner tokens and collections and extends the state machine to\r\n * recognize additional tokens or groups.\r\n */\r\nfunction registerTokenPlugin(name, plugin) {\r\n  if (typeof plugin !== 'function') {\r\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\r\n  }\r\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\r\n    if (name === INIT.tokenQueue[i][0]) {\r\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\r\n      INIT.tokenQueue[i] = [name, plugin];\r\n      return;\r\n    }\r\n  }\r\n  INIT.tokenQueue.push([name, plugin]);\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Register a linkify plugin\r\n * @param {string} name of plugin to register\r\n * @param {Plugin} plugin function that accepts the parser state machine and\r\n * extends the parser to recognize additional link types\r\n */\r\nfunction registerPlugin(name, plugin) {\r\n  if (typeof plugin !== 'function') {\r\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\r\n  }\r\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\r\n    if (name === INIT.pluginQueue[i][0]) {\r\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\r\n      INIT.pluginQueue[i] = [name, plugin];\r\n      return;\r\n    }\r\n  }\r\n  INIT.pluginQueue.push([name, plugin]);\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Detect URLs with the following additional protocol. Anything with format\r\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\r\n * `true`, anything with format \"protocol:...\" will be considered a link.\r\n * @param {string} scheme\r\n * @param {boolean} [optionalSlashSlash]\r\n */\r\nfunction registerCustomProtocol(scheme, optionalSlashSlash = false) {\r\n  if (INIT.initialized) {\r\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\r\n  }\r\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\r\n    throw new Error(`linkifyjs: incorrect scheme format.\r\n1. Must only contain digits, lowercase ASCII letters or \"-\"\r\n2. Cannot start or end with \"-\"\r\n3. \"-\" cannot repeat`);\r\n  }\r\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\r\n}\r\n\r\n/**\r\n * Initialize the linkify state machine. Called automatically the first time\r\n * linkify is called on a string, but may be called manually as well.\r\n */\r\nfunction init() {\r\n  // Initialize scanner state machine and plugins\r\n  INIT.scanner = init$2(INIT.customSchemes);\r\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\r\n    INIT.tokenQueue[i][1]({\r\n      scanner: INIT.scanner\r\n    });\r\n  }\r\n\r\n  // Initialize parser state machine and plugins\r\n  INIT.parser = init$1(INIT.scanner.tokens);\r\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\r\n    INIT.pluginQueue[i][1]({\r\n      scanner: INIT.scanner,\r\n      parser: INIT.parser\r\n    });\r\n  }\r\n  INIT.initialized = true;\r\n  return INIT;\r\n}\r\n\r\n/**\r\n * Parse a string into tokens that represent linkable and non-linkable sub-components\r\n * @param {string} str\r\n * @return {MultiToken[]} tokens\r\n */\r\nfunction tokenize(str) {\r\n  if (!INIT.initialized) {\r\n    init();\r\n  }\r\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\r\n}\r\ntokenize.scan = run$1; // for testing\r\n\r\n/**\r\n * Find a list of linkable items in the given string.\r\n * @param {string} str string to find links in\r\n * @param {string | Opts} [type] either formatting options or specific type of\r\n * links to find, e.g., 'url' or 'email'\r\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\r\n * if opts already provided in `type` argument\r\n */\r\nfunction find(str, type = null, opts = null) {\r\n  if (type && typeof type === 'object') {\r\n    if (opts) {\r\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\r\n    }\r\n    opts = type;\r\n    type = null;\r\n  }\r\n  const options = new Options(opts);\r\n  const tokens = tokenize(str);\r\n  const filtered = [];\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    const token = tokens[i];\r\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\r\n      filtered.push(token.toFormattedObject(options));\r\n    }\r\n  }\r\n  return filtered;\r\n}\r\n\r\n/**\r\n * Is the given string valid linkable text of some sort. Note that this does not\r\n * trim the text for you.\r\n *\r\n * Optionally pass in a second `type` param, which is the type of link to test\r\n * for.\r\n *\r\n * For example,\r\n *\r\n *     linkify.test(str, 'email');\r\n *\r\n * Returns `true` if str is a valid email.\r\n * @param {string} str string to test for links\r\n * @param {string} [type] optional specific link type to look for\r\n * @returns boolean true/false\r\n */\r\nfunction test(str, type = null) {\r\n  const tokens = tokenize(str);\r\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\r\n}\r\n\r\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, multi as text, tokenize };\r\n", "import type { PasteRuleMatch } from '@tiptap/core'\nimport { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport type { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\nimport { UNICODE_WHITESPACE_REGEX_GLOBAL } from './helpers/whitespace.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean\n}\n\nexport const pasteRegex =\n  /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\n/**\n * @deprecated The default behavior is now to open links when the editor is not editable.\n */\ntype DeprecatedOpenWhenNotEditable = 'whenNotEditable'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>\n\n  /**\n   * Default protocol to use when no protocol is specified.\n   * @default 'http'\n   */\n  defaultProtocol: string\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   */\n  openOnClick: boolean | DeprecatedOpenWhenNotEditable\n  /**\n   * If enabled, the link will be selected when clicked.\n   * @default false\n   * @example true\n   */\n  enableClickSelection: boolean\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * @deprecated Use the `shouldAutoLink` option instead.\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate: (url: string) => boolean\n\n  /**\n   * A validation function which is used for configuring link verification for preventing XSS attacks.\n   * Only modify this if you know what you're doing.\n   *\n   * @returns {boolean} `true` if the URL is valid, `false` otherwise.\n   *\n   * @example\n   * isAllowedUri: (url, { defaultValidate, protocols, defaultProtocol }) => {\n   * return url.startsWith('./') || defaultValidate(url)\n   * }\n   */\n  isAllowedUri: (\n    /**\n     * The URL to be validated.\n     */\n    url: string,\n    ctx: {\n      /**\n       * The default validation function.\n       */\n      defaultValidate: (url: string) => boolean\n      /**\n       * An array of allowed protocols for the URL (e.g., \"http\", \"https\"). As defined in the `protocols` option.\n       */\n      protocols: Array<LinkProtocolOptions | string>\n      /**\n       * A string that represents the default protocol (e.g., 'http'). As defined in the `defaultProtocol` option.\n       */\n      defaultProtocol: string\n    },\n  ) => boolean\n\n  /**\n   * Determines whether a valid link should be automatically linked in the content.\n   *\n   * @param {string} url - The URL that has already been validated.\n   * @returns {boolean} - True if the link should be auto-linked; false if it should not be auto-linked.\n   */\n  shouldAutoLink: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n      }) => ReturnType\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes?: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n      }) => ReturnType\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\nexport function isAllowedUri(uri: string | undefined, protocols?: LinkOptions['protocols']) {\n  const allowedProtocols: string[] = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp']\n\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme\n\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol)\n      }\n    })\n  }\n\n  return (\n    !uri ||\n    uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, '').match(\n      new RegExp(\n        // eslint-disable-next-line no-useless-escape\n        `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`,\n        'i',\n      ),\n    )\n  )\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  exitable: true,\n\n  onCreate() {\n    // TODO: v4 - remove validate option\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      // Copy the validate function to the shouldAutoLink option\n      this.options.shouldAutoLink = this.options.validate\n      console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.')\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => {\n        // URLs with explicit protocols (e.g., https://) should be auto-linked\n        // But not if @ appears before :// (that would be userinfo like user:pass@host)\n        const hasProtocol = /^[a-z][a-z0-9+.-]*:\\/\\//i.test(url)\n        const hasMaybeProtocol = /^[a-z][a-z0-9+.-]*:/i.test(url)\n\n        if (hasProtocol || (hasMaybeProtocol && !url.includes('@'))) {\n          return true\n        }\n        // Strip userinfo (user:pass@) if present, then extract hostname\n        const urlWithoutUserinfo = url.includes('@') ? url.split('@').pop()! : url\n        const hostname = urlWithoutUserinfo.split(/[/?#:]/)[0]\n\n        // Don't auto-link IP addresses without protocol\n        if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(hostname)) {\n          return false\n        }\n        // Don't auto-link single-word hostnames without TLD (e.g., \"localhost\")\n        if (!/\\./.test(hostname)) {\n          return false\n        }\n        return true\n      },\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href')\n        },\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'a[href]',\n        getAttrs: dom => {\n          const href = (dom as HTMLElement).getAttribute('href')\n\n          // prevent XSS attacks\n          if (\n            !href ||\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n          return null\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // prevent XSS attacks\n    if (\n      !this.options.isAllowedUri(HTMLAttributes.href, {\n        defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n        protocols: this.options.protocols,\n        defaultProtocol: this.options.defaultProtocol,\n      })\n    ) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0]\n    }\n\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'link',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark('link', helpers.parseInline(token.tokens || []), {\n      href: token.href,\n      title: token.title || null,\n    })\n  },\n\n  renderMarkdown: (node, h) => {\n    const href = node.attrs?.href || ''\n    const text = h.renderChildren(node)\n\n    return `[${text}](${href})`\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes\n\n          if (\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes || {}\n\n          if (\n            href &&\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () =>\n        ({ chain }) => {\n          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta('preventAutolink', true).run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const { protocols, defaultProtocol } = this.options\n            const links = find(text).filter(\n              item =>\n                item.isLink &&\n                this.options.isAllowedUri(item.value, {\n                  defaultValidate: href => !!isAllowedUri(href, protocols),\n                  protocols,\n                  defaultProtocol,\n                }),\n            )\n\n            if (links.length) {\n              links.forEach(link => {\n                if (!this.options.shouldAutoLink(link.value)) {\n                  return\n                }\n\n                foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href,\n                  },\n                  index: link.start,\n                })\n              })\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n    const { protocols, defaultProtocol } = this.options\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: url =>\n            this.options.isAllowedUri(url, {\n              defaultValidate: href => !!isAllowedUri(href, protocols),\n              protocols,\n              defaultProtocol,\n            }),\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    plugins.push(\n      clickHandler({\n        type: this.type,\n        editor: this.editor,\n        openOnClick: this.options.openOnClick === 'whenNotEditable' ? true : this.options.openOnClick,\n        enableClickSelection: this.options.enableClickSelection,\n      }),\n    )\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n", "import type { NodeWithPos } from '@tiptap/core'\nimport { combineTransactionSteps, findChildrenInRange, getChangedRanges, getMarksBetween } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { MultiToken } from 'linkifyjs'\nimport { tokenize } from 'linkifyjs'\n\nimport { UNICODE_WHITESPACE_REGEX, UNICODE_WHITESPACE_REGEX_END } from './whitespace.js'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  defaultProtocol: string\n  validate: (url: string) => boolean\n  shouldAutoLink: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now let’s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ')\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return\n          }\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ')\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean)\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol))\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code)\n            })\n            // validate link\n            .filter(link => options.validate(link.value))\n            // check whether should autolink\n            .filter(link => options.shouldAutoLink(link.value))\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n", "// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.ts\nexport const UNICODE_WHITESPACE_PATTERN = '[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]'\n\nexport const UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN)\nexport const UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`)\nexport const UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, 'g')\n", "import type { Editor } from '@tiptap/core'\nimport { getAttributes } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType\n  editor: Editor\n  openOnClick?: boolean\n  enableClickSelection?: boolean\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (event.button !== 0) {\n          return false\n        }\n\n        if (!view.editable) {\n          return false\n        }\n\n        let link: HTMLAnchorElement | null = null\n\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target\n        } else {\n          const target = event.target as HTMLElement | null\n          if (!target) {\n            return false\n          }\n\n          const root = options.editor.view.dom\n\n          // Tntentionally limit the lookup to the editor root.\n          // Using tag names like DIV as boundaries breaks with custom NodeViews,\n          link = target.closest<HTMLAnchorElement>('a')\n\n          if (link && !root.contains(link)) {\n            link = null\n          }\n        }\n\n        if (!link) {\n          return false\n        }\n\n        let handled = false\n\n        if (options.enableClickSelection) {\n          const commandResult = options.editor.commands.extendMarkRange(options.type.name)\n          handled = commandResult\n        }\n\n        if (options.openOnClick) {\n          const attrs = getAttributes(view.state, options.type.name)\n          const href = link.href ?? attrs.href\n          const target = link.target ?? attrs.target\n\n          if (href) {\n            window.open(href, target)\n            handled = true\n          }\n        }\n\n        return handled\n      },\n    },\n  })\n}\n", "import type { Editor } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\nimport type { LinkOptions } from '../link.js'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  defaultProtocol: string\n  type: MarkType\n  shouldAutoLink?: LinkOptions['shouldAutoLink']\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, _event, slice) => {\n        const { shouldAutoLink } = options\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          item => item.isLink && item.value === textContent,\n        )\n\n        if (!textContent || !link || (shouldAutoLink !== undefined && !shouldAutoLink(link.value))) {\n          return false\n        }\n\n        return options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n      },\n    },\n  })\n}\n", "import { Link } from './link.js'\n\nexport * from './link.js'\n\nexport default Link\n", "import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || (token as any).ordered) {\n      return []\n    }\n\n    return {\n      type: 'bulletList',\n      content: token.items ? helpers.parseChildren(token.items) : [],\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n", "import { mergeAttributes, Node, renderNestedMarkdownContent } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list_item',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list_item') {\n      return []\n    }\n\n    let content: any[] = []\n\n    if (token.tokens && token.tokens.length > 0) {\n      // Check if we have paragraph tokens (complex list items)\n      const hasParagraphTokens = token.tokens.some(t => t.type === 'paragraph')\n\n      if (hasParagraphTokens) {\n        // If we have paragraph tokens, parse them as block elements\n        content = helpers.parseChildren(token.tokens)\n      } else {\n        // Check if the first token is a text token with nested inline tokens\n        const firstToken = token.tokens[0]\n\n        if (firstToken && firstToken.type === 'text' && firstToken.tokens && firstToken.tokens.length > 0) {\n          // Parse the inline content from the text token\n          const inlineContent = helpers.parseInline(firstToken.tokens)\n\n          // Start with the paragraph containing the inline content\n          content = [\n            {\n              type: 'paragraph',\n              content: inlineContent,\n            },\n          ]\n\n          // If there are additional tokens after the first text token (like nested lists),\n          // parse them as block elements and add them\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1)\n            const additionalContent = helpers.parseChildren(remainingTokens)\n            content.push(...additionalContent)\n          }\n        } else {\n          // Fallback: parse all tokens as block elements\n          content = helpers.parseChildren(token.tokens)\n        }\n      }\n    }\n\n    // Ensure we always have at least an empty paragraph\n    if (content.length === 0) {\n      content = [\n        {\n          type: 'paragraph',\n          content: [],\n        },\n      ]\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(\n      node,\n      h,\n      (context: any) => {\n        if (context.parentType === 'bulletList') {\n          return '- '\n        }\n        if (context.parentType === 'orderedList') {\n          const start = context.meta?.parentAttrs?.start || 1\n          return `${start + context.index}. `\n        }\n        // Fallback to bullet list for unknown parent types\n        return '- '\n      },\n      ctx,\n    )\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n", "import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n", "export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n", "import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n", "import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n", "import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n", "import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n", "import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n", "import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n", "import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * It’s a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n", "import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nimport { buildNestedStructure, collectOrderedListItems, parseListItems } from './utils.js'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || !token.ordered) {\n      return []\n    }\n\n    const startValue = token.start || 1\n    const content = token.items ? parseListItems(token.items, helpers) : []\n\n    if (startValue !== 1) {\n      return {\n        type: 'orderedList',\n        attrs: { start: startValue },\n        content,\n      }\n    }\n\n    return {\n      type: 'orderedList',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'orderedList',\n    level: 'block',\n    start: (src: string) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/)\n      const index = match?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize: (src: string, _tokens, lexer) => {\n      const lines = src.split('\\n')\n      const [listItems, consumed] = collectOrderedListItems(lines)\n\n      if (listItems.length === 0) {\n        return undefined\n      }\n\n      const items = buildNestedStructure(listItems, 0, lexer)\n\n      if (items.length === 0) {\n        return undefined\n      }\n\n      const startValue = listItems[0]?.number || 1\n\n      return {\n        type: 'list',\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join('\\n'),\n      } as unknown as object\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n", "import type { JSONContent, MarkdownLexerConfiguration, MarkdownParseHelpers, MarkdownToken } from '@tiptap/core'\n\n/**\n * Matches an ordered list item line with optional leading whitespace.\n * Captures: (1) indentation spaces, (2) item number, (3) content after marker\n * Example matches: \"1. Item\", \"  2. Nested item\", \"    3. Deeply nested\"\n */\nconst ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/\n\n/**\n * Matches any line that starts with whitespace (indented content).\n * Used to identify continuation content that belongs to a list item.\n */\nconst INDENTED_LINE_REGEX = /^\\s/\n\n/**\n * Represents a parsed ordered list item with indentation information\n */\nexport interface OrderedListItem {\n  indent: number\n  number: number\n  content: string\n  raw: string\n}\n\n/**\n * Collects all ordered list items from lines, parsing them into a flat array\n * with indentation information. Stops collecting continuation content when\n * encountering nested list items, allowing them to be processed separately.\n *\n * @param lines - Array of source lines to parse\n * @returns Tuple of [listItems array, number of lines consumed]\n */\nexport function collectOrderedListItems(lines: string[]): [OrderedListItem[], number] {\n  const listItems: OrderedListItem[] = []\n  let currentLineIndex = 0\n  let consumed = 0\n\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex]\n    const match = line.match(ORDERED_LIST_ITEM_REGEX)\n\n    if (!match) {\n      break\n    }\n\n    const [, indent, number, content] = match\n    const indentLevel = indent.length\n    let itemContent = content\n    let nextLineIndex = currentLineIndex + 1\n    const itemLines = [line]\n\n    // Collect continuation lines for this item (but NOT nested list items)\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex]\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX)\n\n      // If it's another list item (nested or not), stop collecting\n      if (nextMatch) {\n        break\n      }\n\n      // Check for continuation content (non-list content)\n      if (nextLine.trim() === '') {\n        // Empty line\n        itemLines.push(nextLine)\n        itemContent += '\\n'\n        nextLineIndex += 1\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        // Indented content - part of this item (but not a list item)\n        itemLines.push(nextLine)\n        itemContent += `\\n${nextLine.slice(indentLevel + 2)}` // Remove list marker indent\n        nextLineIndex += 1\n      } else {\n        // Non-indented line means end of list\n        break\n      }\n    }\n\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join('\\n'),\n    })\n\n    consumed = nextLineIndex\n    currentLineIndex = nextLineIndex\n  }\n\n  return [listItems, consumed]\n}\n\n/**\n * Recursively builds a nested structure from a flat array of list items\n * based on their indentation levels. Creates proper markdown tokens with\n * nested lists where appropriate.\n *\n * @param items - Flat array of list items with indentation info\n * @param baseIndent - The indentation level to process at this recursion level\n * @param lexer - Markdown lexer for parsing inline and block content\n * @returns Array of list_item tokens with proper nesting\n */\nexport function buildNestedStructure(\n  items: OrderedListItem[],\n  baseIndent: number,\n  lexer: MarkdownLexerConfiguration,\n): unknown[] {\n  const result: unknown[] = []\n  let currentIndex = 0\n\n  while (currentIndex < items.length) {\n    const item = items[currentIndex]\n\n    if (item.indent === baseIndent) {\n      // This item belongs at the current level\n      const contentLines = item.content.split('\\n')\n      const mainText = contentLines[0]?.trim() || ''\n\n      const tokens = []\n\n      // Always wrap the main text in a paragraph token\n      if (mainText) {\n        tokens.push({\n          type: 'paragraph',\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText),\n        })\n      }\n\n      // Handle additional content after the main text\n      const additionalContent = contentLines.slice(1).join('\\n').trim()\n      if (additionalContent) {\n        // Parse as block tokens (handles mixed unordered lists, etc.)\n        const blockTokens = lexer.blockTokens(additionalContent)\n        tokens.push(...blockTokens)\n      }\n\n      // Look ahead to find nested items at deeper indent levels\n      let lookAheadIndex = currentIndex + 1\n      const nestedItems = []\n\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex])\n        lookAheadIndex += 1\n      }\n\n      // If we have nested items, recursively build their structure\n      if (nestedItems.length > 0) {\n        // Find the next indent level (immediate children)\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent))\n\n        // Build the nested list recursively with all nested items\n        // The recursive call will handle further nesting\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer)\n\n        // Create a nested list token\n        tokens.push({\n          type: 'list',\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join('\\n'),\n        })\n      }\n\n      result.push({\n        type: 'list_item',\n        raw: item.raw,\n        tokens,\n      })\n\n      // Skip the nested items we just processed\n      currentIndex = lookAheadIndex\n    } else {\n      // This item has deeper indent than we're currently processing\n      // It should be handled by a recursive call\n      currentIndex += 1\n    }\n  }\n\n  return result\n}\n\n/**\n * Parses markdown list item tokens into Tiptap JSONContent structure,\n * ensuring text content is properly wrapped in paragraph nodes.\n *\n * @param items - Array of markdown tokens representing list items\n * @param helpers - Markdown parse helpers for recursive parsing\n * @returns Array of listItem JSONContent nodes\n */\nexport function parseListItems(items: MarkdownToken[], helpers: MarkdownParseHelpers): JSONContent[] {\n  return items.map(item => {\n    if (item.type !== 'list_item') {\n      return helpers.parseChildren([item])[0]\n    }\n\n    // Parse the tokens within the list item\n    const content: JSONContent[] = []\n\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        // If it's already a proper block node (paragraph, list, etc.), parse it directly\n        if (\n          itemToken.type === 'paragraph' ||\n          itemToken.type === 'list' ||\n          itemToken.type === 'blockquote' ||\n          itemToken.type === 'code'\n        ) {\n          content.push(...helpers.parseChildren([itemToken]))\n        } else if (itemToken.type === 'text' && itemToken.tokens) {\n          // If it's inline text tokens, wrap them in a paragraph\n          const inlineContent = helpers.parseChildren([itemToken])\n          content.push({\n            type: 'paragraph',\n            content: inlineContent,\n          })\n        } else {\n          // For any other content, try to parse it\n          const parsed = helpers.parseChildren([itemToken])\n          if (parsed.length > 0) {\n            content.push(...parsed)\n          }\n        }\n      })\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  })\n}\n", "import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport {\n  getRenderedAttributes,\n  mergeAttributes,\n  Node,\n  renderNestedMarkdownContent,\n  wrappingInputRule,\n} from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  parseMarkdown: (token, h) => {\n    // Parse the task item's text content into paragraph content\n    const content = []\n\n    // First, add the main paragraph content\n    if (token.tokens && token.tokens.length > 0) {\n      // If we have tokens, create a paragraph with the inline content\n      content.push(h.createNode('paragraph', {}, h.parseInline(token.tokens)))\n    } else if (token.text) {\n      // If we have raw text, create a paragraph with text node\n      content.push(h.createNode('paragraph', {}, [h.createNode('text', { text: token.text })]))\n    } else {\n      // Fallback: empty paragraph\n      content.push(h.createNode('paragraph', {}, []))\n    }\n\n    // Then, add any nested content (like nested task lists)\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens)\n      content.push(...nestedContent)\n    }\n\n    return h.createNode('taskItem', { checked: token.checked || false }, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    const checkedChar = node.attrs?.checked ? 'x' : ' '\n    const prefix = `- [${checkedChar}] `\n\n    return renderNestedMarkdownContent(node, h, prefix)\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isn’t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      // Track the keys of previously rendered HTML attributes for proper removal\n      let prevRenderedAttributeKeys = new Set(Object.keys(HTMLAttributes))\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          // Sync all HTML attributes from the updated node\n          const extensionAttributes = editor.extensionManager.attributes\n          const newHTMLAttributes = getRenderedAttributes(updatedNode, extensionAttributes)\n          const newKeys = new Set(Object.keys(newHTMLAttributes))\n\n          // Remove attributes that were previously rendered but are no longer present\n          // If the attribute exists in static options, restore it instead of removing\n          const staticAttrs = this.options.HTMLAttributes\n\n          prevRenderedAttributeKeys.forEach(key => {\n            if (!newKeys.has(key)) {\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key])\n              } else {\n                listItem.removeAttribute(key)\n              }\n            }\n          })\n\n          // Update or add new attributes\n          Object.entries(newHTMLAttributes).forEach(([key, value]) => {\n            if (value === null || value === undefined) {\n              // If the attribute exists in static options, restore it instead of removing\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key])\n              } else {\n                listItem.removeAttribute(key)\n              }\n            } else {\n              listItem.setAttribute(key, value)\n            }\n          })\n\n          // Update the tracked keys for next update\n          prevRenderedAttributeKeys = newKeys\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n", "import { mergeAttributes, Node, parseIndentedBlocks } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.createNode('taskList', {}, h.parseChildren(token.items || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'taskList',\n    level: 'block',\n    start(src) {\n      // Look for the start of a task list item\n      const index = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize(src, tokens, lexer) {\n      // Helper function to recursively parse task lists\n      const parseTaskListContent = (content: string): any[] | undefined => {\n        const nestedResult = parseIndentedBlocks(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: match => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === 'x',\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: 'taskItem',\n              raw: '',\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens,\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent,\n          },\n          lexer,\n        )\n\n        if (nestedResult) {\n          // Return as task list token\n          return [\n            {\n              type: 'taskList',\n              raw: nestedResult.raw,\n              items: nestedResult.items,\n            },\n          ]\n        }\n\n        // Fall back to regular markdown parsing if not a task list\n        return lexer.blockTokens(content)\n      }\n\n      const result = parseIndentedBlocks(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === 'x',\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: 'taskItem',\n            raw: '',\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens,\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent,\n        },\n        lexer,\n      )\n\n      if (!result) {\n        return undefined\n      }\n\n      return {\n        type: 'taskList',\n        raw: result.raw,\n        items: result.items,\n      }\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n", "import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  /**\n   * The HTML attributes for a paragraph node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       * @example editor.commands.toggleParagraph()\n       */\n      setParagraph: () => ReturnType\n    }\n  }\n}\n\n/**\n * Markdown marker for empty paragraphs to preserve blank lines.\n * Using &nbsp; (non-breaking space HTML entity) ensures the paragraph\n * is not collapsed by markdown parsers while remaining human-readable.\n */\nconst EMPTY_PARAGRAPH_MARKDOWN = '&nbsp;'\n\n/**\n * Unicode character for non-breaking space (U+00A0).\n * Some markdown parsers may convert &nbsp; entities to this literal character.\n */\nconst NBSP_CHAR = '\\u00A0'\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [{ tag: 'p' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || []\n\n    // Special case: if paragraph contains only a single image token,\n    // unwrap it to avoid nesting block elements incorrectly\n    if (tokens.length === 1 && tokens[0].type === 'image') {\n      // Parse the image token directly as a block element\n      return helpers.parseChildren([tokens[0]])\n    }\n\n    // Parse the inline tokens\n    const content = helpers.parseInline(tokens)\n\n    // Special case: if paragraph contains only &nbsp; (non-breaking space),\n    // treat it as an empty paragraph to preserve blank lines\n    if (\n      content.length === 1 &&\n      content[0].type === 'text' &&\n      (content[0].text === EMPTY_PARAGRAPH_MARKDOWN || content[0].text === NBSP_CHAR)\n    ) {\n      return helpers.createNode('paragraph', undefined, [])\n    }\n\n    // Convert 'paragraph' token to paragraph node\n    return helpers.createNode('paragraph', undefined, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node) {\n      return ''\n    }\n\n    // Normalize content: treat undefined/null as empty array\n    const content = Array.isArray(node.content) ? node.content : []\n\n    // If the paragraph is empty, render a non-breaking space to preserve blank lines\n    if (content.length === 0) {\n      return EMPTY_PARAGRAPH_MARKDOWN\n    }\n\n    return h.renderChildren(content)\n  },\n\n  addCommands() {\n    return {\n      setParagraph:\n        () =>\n        ({ commands }) => {\n          return commands.setNode(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n", "import { Paragraph } from './paragraph.js'\n\nexport * from './paragraph.js'\n\nexport default Paragraph\n", "import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface StrikeOptions {\n  /**\n   * HTML attributes to add to the strike element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    strike: {\n      /**\n       * Set a strike mark\n       * @example editor.commands.setStrike()\n       */\n      setStrike: () => ReturnType\n      /**\n       * Toggle a strike mark\n       * @example editor.commands.toggleStrike()\n       */\n      toggleStrike: () => ReturnType\n      /**\n       * Unset a strike mark\n       * @example editor.commands.unsetStrike()\n       */\n      unsetStrike: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nexport const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/\n\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nexport const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g\n\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'del',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'del' token to strike mark\n    return helpers.applyMark('strike', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`\n  },\n\n  addCommands() {\n    return {\n      setStrike:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleStrike:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetStrike:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n", "import { Strike } from './strike.js'\n\nexport * from './strike.js'\n\nexport default Strike\n", "import { Node } from '@tiptap/core'\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n\n  parseMarkdown: token => {\n    // Convert 'text' token to text node - text nodes are special as they store text directly\n    return {\n      type: 'text',\n      text: token.text || '',\n    }\n  },\n\n  renderMarkdown: node => node.text || '',\n})\n", "import { Text } from './text.js'\n\nexport * from './text.js'\n\nexport default Text\n", "import { Mark, mergeAttributes } from '@tiptap/core'\n\nexport interface UnderlineOptions {\n  /**\n   * HTML attributes to add to the underline element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    underline: {\n      /**\n       * Set an underline mark\n       * @example editor.commands.setUnderline()\n       */\n      setUnderline: () => ReturnType\n      /**\n       * Toggle an underline mark\n       * @example editor.commands.toggleUnderline()\n       */\n      toggleUnderline: () => ReturnType\n      /**\n       * Unset an underline mark\n       * @example editor.commands.unsetUnderline()\n       */\n      unsetUnderline: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nexport const Underline = Mark.create<UnderlineOptions>({\n  name: 'underline',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'u',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('underline') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown(token, helpers) {\n    return helpers.applyMark(this.name || 'underline', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown(node, helpers) {\n    return `++${helpers.renderChildren(node)}++`\n  },\n\n  markdownTokenizer: {\n    name: 'underline',\n    level: 'inline',\n    start(src) {\n      return src.indexOf('++')\n    },\n    tokenize(src, _tokens, lexer) {\n      const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/\n      const match = rule.exec(src)\n\n      if (!match) {\n        return undefined\n      }\n\n      const innerContent = match[2].trim()\n\n      return {\n        type: 'underline',\n        raw: match[0],\n        text: innerContent,\n        tokens: lexer.inlineTokens(innerContent),\n      }\n    },\n  },\n\n  addCommands() {\n    return {\n      setUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-u': () => this.editor.commands.toggleUnderline(),\n      'Mod-U': () => this.editor.commands.toggleUnderline(),\n    }\n  },\n})\n", "import { Underline } from './underline.js'\n\nexport * from './underline.js'\n\nexport default Underline\n", "import { Extension } from '@tiptap/core'\nimport type { BlockquoteOptions } from '@tiptap/extension-blockquote'\nimport { Blockquote } from '@tiptap/extension-blockquote'\nimport type { BoldOptions } from '@tiptap/extension-bold'\nimport { Bold } from '@tiptap/extension-bold'\nimport type { CodeOptions } from '@tiptap/extension-code'\nimport { Code } from '@tiptap/extension-code'\nimport type { CodeBlockOptions } from '@tiptap/extension-code-block'\nimport { CodeBlock } from '@tiptap/extension-code-block'\nimport { Document } from '@tiptap/extension-document'\nimport type { HardBreakOptions } from '@tiptap/extension-hard-break'\nimport { HardBreak } from '@tiptap/extension-hard-break'\nimport type { HeadingOptions } from '@tiptap/extension-heading'\nimport { Heading } from '@tiptap/extension-heading'\nimport type { HorizontalRuleOptions } from '@tiptap/extension-horizontal-rule'\nimport { HorizontalRule } from '@tiptap/extension-horizontal-rule'\nimport type { ItalicOptions } from '@tiptap/extension-italic'\nimport { Italic } from '@tiptap/extension-italic'\nimport type { LinkOptions } from '@tiptap/extension-link'\nimport { Link } from '@tiptap/extension-link'\nimport type { BulletListOptions, ListItemOptions, ListKeymapOptions, OrderedListOptions } from '@tiptap/extension-list'\nimport { BulletList, ListItem, ListKeymap, OrderedList } from '@tiptap/extension-list'\nimport type { ParagraphOptions } from '@tiptap/extension-paragraph'\nimport { Paragraph } from '@tiptap/extension-paragraph'\nimport type { StrikeOptions } from '@tiptap/extension-strike'\nimport { Strike } from '@tiptap/extension-strike'\nimport { Text } from '@tiptap/extension-text'\nimport type { UnderlineOptions } from '@tiptap/extension-underline'\nimport { Underline } from '@tiptap/extension-underline'\nimport type { DropcursorOptions, TrailingNodeOptions, UndoRedoOptions } from '@tiptap/extensions'\nimport { Dropcursor, Gapcursor, TrailingNode, UndoRedo } from '@tiptap/extensions'\n\nexport interface StarterKitOptions {\n  /**\n   * If set to false, the blockquote extension will not be registered\n   * @example blockquote: false\n   */\n  blockquote: Partial<BlockquoteOptions> | false\n\n  /**\n   * If set to false, the bold extension will not be registered\n   * @example bold: false\n   */\n  bold: Partial<BoldOptions> | false\n\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example bulletList: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n\n  /**\n   * If set to false, the code extension will not be registered\n   * @example code: false\n   */\n  code: Partial<CodeOptions> | false\n\n  /**\n   * If set to false, the codeBlock extension will not be registered\n   * @example codeBlock: false\n   */\n  codeBlock: Partial<CodeBlockOptions> | false\n\n  /**\n   * If set to false, the document extension will not be registered\n   * @example document: false\n   */\n  document: false\n\n  /**\n   * If set to false, the dropcursor extension will not be registered\n   * @example dropcursor: false\n   */\n  dropcursor: Partial<DropcursorOptions> | false\n\n  /**\n   * If set to false, the gapcursor extension will not be registered\n   * @example gapcursor: false\n   */\n  gapcursor: false\n\n  /**\n   * If set to false, the hardBreak extension will not be registered\n   * @example hardBreak: false\n   */\n  hardBreak: Partial<HardBreakOptions> | false\n\n  /**\n   * If set to false, the heading extension will not be registered\n   * @example heading: false\n   */\n  heading: Partial<HeadingOptions> | false\n\n  /**\n   * If set to false, the undo-redo extension will not be registered\n   * @example undoRedo: false\n   */\n  undoRedo: Partial<UndoRedoOptions> | false\n\n  /**\n   * If set to false, the horizontalRule extension will not be registered\n   * @example horizontalRule: false\n   */\n  horizontalRule: Partial<HorizontalRuleOptions> | false\n\n  /**\n   * If set to false, the italic extension will not be registered\n   * @example italic: false\n   */\n  italic: Partial<ItalicOptions> | false\n\n  /**\n   * If set to false, the listItem extension will not be registered\n   * @example listItem: false\n   */\n  listItem: Partial<ListItemOptions> | false\n\n  /**\n   * If set to false, the listItemKeymap extension will not be registered\n   * @example listKeymap: false\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n\n  /**\n   * If set to false, the link extension will not be registered\n   * @example link: false\n   */\n  link: Partial<LinkOptions> | false\n\n  /**\n   * If set to false, the orderedList extension will not be registered\n   * @example orderedList: false\n   */\n  orderedList: Partial<OrderedListOptions> | false\n\n  /**\n   * If set to false, the paragraph extension will not be registered\n   * @example paragraph: false\n   */\n  paragraph: Partial<ParagraphOptions> | false\n\n  /**\n   * If set to false, the strike extension will not be registered\n   * @example strike: false\n   */\n  strike: Partial<StrikeOptions> | false\n\n  /**\n   * If set to false, the text extension will not be registered\n   * @example text: false\n   */\n  text: false\n\n  /**\n   * If set to false, the underline extension will not be registered\n   * @example underline: false\n   */\n  underline: Partial<UnderlineOptions> | false\n\n  /**\n   * If set to false, the trailingNode extension will not be registered\n   * @example trailingNode: false\n   */\n  trailingNode: Partial<TrailingNodeOptions> | false\n}\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * It’s a good starting point for building your own editor.\n */\nexport const StarterKit = Extension.create<StarterKitOptions>({\n  name: 'starterKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bold !== false) {\n      extensions.push(Bold.configure(this.options.bold))\n    }\n\n    if (this.options.blockquote !== false) {\n      extensions.push(Blockquote.configure(this.options.blockquote))\n    }\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.code !== false) {\n      extensions.push(Code.configure(this.options.code))\n    }\n\n    if (this.options.codeBlock !== false) {\n      extensions.push(CodeBlock.configure(this.options.codeBlock))\n    }\n\n    if (this.options.document !== false) {\n      extensions.push(Document.configure(this.options.document))\n    }\n\n    if (this.options.dropcursor !== false) {\n      extensions.push(Dropcursor.configure(this.options.dropcursor))\n    }\n\n    if (this.options.gapcursor !== false) {\n      extensions.push(Gapcursor.configure(this.options.gapcursor))\n    }\n\n    if (this.options.hardBreak !== false) {\n      extensions.push(HardBreak.configure(this.options.hardBreak))\n    }\n\n    if (this.options.heading !== false) {\n      extensions.push(Heading.configure(this.options.heading))\n    }\n\n    if (this.options.undoRedo !== false) {\n      extensions.push(UndoRedo.configure(this.options.undoRedo))\n    }\n\n    if (this.options.horizontalRule !== false) {\n      extensions.push(HorizontalRule.configure(this.options.horizontalRule))\n    }\n\n    if (this.options.italic !== false) {\n      extensions.push(Italic.configure(this.options.italic))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options?.listKeymap))\n    }\n\n    if (this.options.link !== false) {\n      extensions.push(Link.configure(this.options?.link))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.paragraph !== false) {\n      extensions.push(Paragraph.configure(this.options.paragraph))\n    }\n\n    if (this.options.strike !== false) {\n      extensions.push(Strike.configure(this.options.strike))\n    }\n\n    if (this.options.text !== false) {\n      extensions.push(Text.configure(this.options.text))\n    }\n\n    if (this.options.underline !== false) {\n      extensions.push(Underline.configure(this.options?.underline))\n    }\n\n    if (this.options.trailingNode !== false) {\n      extensions.push(TrailingNode.configure(this.options?.trailingNode))\n    }\n\n    return extensions\n  },\n})\n", "import { StarterKit } from './starter-kit.js'\n\nexport type { StarterKitOptions } from './starter-kit.js'\nexport * from './starter-kit.js'\n\nexport default StarterKit\n"],
  "mappings": "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",
  "names": ["h", "h", "inputRegex", "h", "h", "tr", "_a", "h", "tr", "h", "tr", "starInputRegex", "starPasteRegex", "underscoreInputRegex", "underscorePasteRegex", "h", "nextState", "regexp", "Nl", "scheme", "options", "scheme", "options", "options", "tr", "Plugin", "PluginKey", "h", "find", "h", "Node", "mergeAttributes", "getNodeType", "isNodeActive", "ListItemName", "TextStyleName", "wrappingInputRule", "inputRegex", "renderNestedMarkdownContent", "tr", "Extension", "h", "inputRegex", "pasteRegex", "h", "Text", "Text"]
}
